<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mkx7&#39;blog</title>
  
  <subtitle>你可曾与魔鬼在月光下共舞?</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-06-05T09:16:51.960Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>mkx7</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IO_FILE</title>
    <link href="http://example.com/2021/06/05/IO-FILE/"/>
    <id>http://example.com/2021/06/05/IO-FILE/</id>
    <published>2021-06-05T06:38:20.000Z</published>
    <updated>2021-06-05T09:16:51.960Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="IO-FILE笔记"><a href="#IO-FILE笔记" class="headerlink" title="IO_FILE笔记"></a>IO_FILE笔记</h1><p>一篇关于IO_FILE学习的笔记，因为作者这部分刚看所以记录的知识比较肤浅，大部分是作者自己的推测和理解，如果哪里错了请大佬看到轻喷。</p><span id="more"></span><h2 id="IO-FILE结构"><a href="#IO-FILE结构" class="headerlink" title="IO_FILE结构"></a>IO_FILE结构</h2><p>当Linux系统上的程序运行时会使用fopen函数创建FILE结构将其分配在堆中对文件进行处理，FILE是Linux系统标准IO库中专门用于描述文件结构的文件流，它是结构体会记录与文件操作有关的相关变量，每个要处理的文件本质上就是一个FILE，有3个文件流是程序启动时就自动准备好的，分别是stdin、stdout、stderr，此外所有FILE文件流又通过_chain链接成一条链表，表头通过_IO_list_all(libc全局变量，在符号表中可通过pwntools找到)指向(一般它指向IO_2_1_stderr)，通过_IO_list_all就可以控制所有的FILE文件流，这里可以看一张大佬的图片方便理解：</p><p>![image-20210527174147620](D:\web page\blog\themes\yilia\source\assets\img\image1.png)</p><p>下面具体说一下，先看一张图：</p><p>![image-20210527160050312](D:\web page\blog\themes\yilia\source\assets\img\image2.png)</p><p>首先看一下_IO_FILE_plus，它是一个结构体，当打开一个文件时都会从堆上分配内存来存放它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_FILE_plus</span><br><span class="line">&#123;</span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  const struct _IO_jump_t *vtable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>file是Linux 系统标准IO库中描述文件的结构，即最上面说的FILE文件流，实际上是一个结构体，file结构在程序执行fread、fwrite等标准函数时需要文件流指针去调用虚表函数，fopen等函数时会进行创建并分配在堆中，通常可以定义一个指向file结构的指针来接收这个返回值。</p><p>下面是_IO_FILE的结构，_chain链接的即是该部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_FILE &#123;</span><br><span class="line">  int _flags;           /属性标志，由fopen的mode参数决定，高2位字节标志文件，低2位标志程序执行状态/</span><br><span class="line">#define _IO_file_flags _flags</span><br><span class="line"></span><br><span class="line">  /* The following pointers correspond to the C++ streambuf protocol. */</span><br><span class="line">  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span><br><span class="line">  char* _IO_read_ptr;   /* Current read pointer */</span><br><span class="line">  char* _IO_read_end;   /* End of get area. */</span><br><span class="line">  char* _IO_read_base;  /* Start of putback+get area. */</span><br><span class="line">  char* _IO_write_base; /* 起始输入地址 */</span><br><span class="line">  char* _IO_write_ptr;  /* Current put pointer. */</span><br><span class="line">  char* _IO_write_end;  /* 输入结束地址 */</span><br><span class="line">  char* _IO_buf_base;   /* 操作起始地址 */</span><br><span class="line">  char* _IO_buf_end;    /* 操作结束地址 */</span><br><span class="line">  /*控制 _IO_buf_base 和 _IO_buf_end就可以实现任意读写*/</span><br><span class="line">  /* The following fields are used to support backing up and undo. */</span><br><span class="line">  char *_IO_save_base; /* Pointer to start of non-current get area. */</span><br><span class="line">  char *_IO_backup_base;  /* Pointer to first valid character of backup area */</span><br><span class="line">  char *_IO_save_end; /* Pointer to end of non-current get area. */</span><br><span class="line"></span><br><span class="line">  struct _IO_marker *_markers;</span><br><span class="line"></span><br><span class="line">  struct _IO_FILE *_chain;</span><br><span class="line"></span><br><span class="line">  int _fileno;</span><br><span class="line">#if 0</span><br><span class="line">  int _blksize;</span><br><span class="line">#else</span><br><span class="line">  int _flags2;</span><br><span class="line">#endif</span><br><span class="line">  _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */</span><br><span class="line"></span><br><span class="line">#define __HAVE_COLUMN /* temporary */</span><br><span class="line">  /* 1+column number of pbase(); 0 is unknown. */</span><br><span class="line">  unsigned short _cur_column;</span><br><span class="line">  signed char _vtable_offset;</span><br><span class="line">  char _shortbuf[1];</span><br><span class="line"></span><br><span class="line">  /*  char* _save_gptr;  char* _save_egptr; */</span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line">#ifdef _IO_USE_OLD_IO_FILE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再看一下_IO_jump_t，它是一个虚表指针，即vtable虚拟函数表(vtable保存标准流函数底层调用的函数指针，32位偏移FILE结构0x94，64位偏移FILE结构0xd8)，通过它指向FILE会使用的函数。因为有很多函数都调用其中的子函数，无论是关闭文件，还是报错输出等都有对应的字段，所以攻击者可以通过伪造这部分劫持程序流，伪造vtable可以通过任意地址写直接修改vtable中的函数指针或覆写vtable的指针指向可控的内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_jump_t</span><br><span class="line">&#123;</span><br><span class="line">    JUMP_FIELD(size_t, __dummy);</span><br><span class="line">    JUMP_FIELD(size_t, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    /* showmany */</span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">#if 0</span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><p>因为作者比较懒所以不说例题了，直接记一下关于IO_FILE利用的思路。</p><p>第一种利用方式是可以通过_IO_2_1stdout泄露libc地址，具体步骤有很多，大多是使用堆来控制_IO_2_1stdout来泄露libc，比如修改_IO_2_1stdout的_IO_write_base，之后调用puts或printf时即可泄露出_IO_write_base~_IO_write_ptr间的数据。要满足的条件有：</p><p>1、设置_flags &amp; _IO_NO_WRITES = 0</p><p>2、设置_flags &amp; _IO_CURRENTLY_PUTTING = 1</p><p>3、设置_flags &amp; _IO_IS_APPENDING = 1</p><p>4、设置_IO_write_base指向想要泄露的位置，_IO_write_ptr指向泄露结束的地址</p><p>具体原理去看参考的第4条链接吧，大佬讲的太清楚不好意思复制粘贴了。</p><p>第二种是伪造vtable劫持程序流程，因为Linux程序中的IO操作一般都需要通过FILE进行处理，而FILE调用函数进行处理时又是通过vtable指向被调用的函数，因此如果能够伪造vtable结构使其指向受控内存就能控制程序流程，vtable劫持可以通过任意地址写直接改写vtable中的函数指针，通过覆盖vtable指针使其指向受控内存，或者直接伪造整个FILE结构。具体说下上面三种伪造方法：</p><p>先看一下IO函数会使用vtable的哪个函数：</p><p>1、fread函数调用_IO_FILE_plus.vtable中的_IO_XSGETN指针<br>2、fwrite函数调用_IO_FILE_plus.vtable中的_IO_XSPUTN指针，_IO_XSPUTN中会调用同样位于 vtable 中的_IO_OVERFLOW指针<br>3、fclose函数调用_IO_FILE_plus.vtable中的_IO_FINISH指针<br>4、printf/puts与fwrite函数调用大致相同，均会调用_IO_XSPUTN指针和_IO_OVERFLOW指针</p><p>先是通过任意地址写直接改写vtable中的函数指针，上面的这些指针都可以去vtable表中查找偏移，找到要使用的函数和偏移后对函数指针进行修改即可，比如将XSPUTN指针指向system函数，将_IO_FILE_plus头部的内容改为sh，之后fwrite函数中调用xsputn时实际运行system(“sh”)。</p><p>之后是覆盖vtable指针指向受控内存，因为一般情况下vtable无法进入也就无法修改里面的函数指针所以第一种方法并不是很实用，再说下第二种伪造vtable即改写_IO_FILE_plus的vtable指针指向可控内存，在可控内存中布置fake_vtable，之后去指向在fake_vtable中伪造的函数就可以实现程序控制。</p><p>最后一个是伪造FILE结构，比如一个正常的FILE是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p  *(struct _IO_FILE_plus *) stdout</span><br><span class="line">$2 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 0xfbad2887, </span><br><span class="line">    _IO_read_ptr = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_read_end = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_read_base = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_base = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_ptr = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_end = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_buf_base = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_buf_end = 0x7f5b6742a6a4 &lt;_IO_2_1_stdout_+132&gt; &quot;&quot;, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x7f5b674298e0 &lt;_IO_2_1_stdin_&gt;, </span><br><span class="line">    _fileno = 0x1, </span><br><span class="line">    _flags2 = 0x0, </span><br><span class="line">    _old_offset = 0xffffffffffffffff, </span><br><span class="line">    _cur_column = 0x0, </span><br><span class="line">    _vtable_offset = 0x0, </span><br><span class="line">    _shortbuf = &quot;\n&quot;, </span><br><span class="line">    _lock = 0x7f5b6742b780 &lt;_IO_stdfile_1_lock&gt;, </span><br><span class="line">    _offset = 0xffffffffffffffff, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x7f5b674297a0 &lt;_IO_wide_data_1&gt;, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0x0, </span><br><span class="line">    _mode = 0xffffffff, </span><br><span class="line">    _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x7f5b674286e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想伪造FILE需要绕过_flags的检查，同时满足flag&amp;8=0、flag &amp;2 =0、flag &amp; 0x8000 != 0，所以flag的值可以为0xfbad8000或者0xfbad8080。其他的结构按照之前的伪造即可，伪造后的FILE是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p *(struct _IO_FILE_plus *)0x602090</span><br><span class="line">$1 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 0xfbad8000, </span><br><span class="line">    _IO_read_ptr = 0x602060 &quot;  `&quot;, </span><br><span class="line">    _IO_read_end = 0x602060 &quot;  `&quot;, </span><br><span class="line">    _IO_read_base = 0x602060 &quot;  `&quot;, </span><br><span class="line">    _IO_write_base = 0x602060 &quot;  `&quot;, </span><br><span class="line">    _IO_write_ptr = 0x602060 &quot;  `&quot;, </span><br><span class="line">    _IO_write_end = 0x602060 &quot;  `&quot;, </span><br><span class="line">    _IO_buf_base = 0x602060 &quot;  `&quot;, </span><br><span class="line">    _IO_buf_end = 0x602061 &quot; `&quot;, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x602060, </span><br><span class="line">    _fileno = 0x1, </span><br><span class="line">    _flags2 = 0x0, </span><br><span class="line">    _old_offset = 0xffffffffffffffff, </span><br><span class="line">    _cur_column = 0x0, </span><br><span class="line">    _vtable_offset = 0x0, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x602060, </span><br><span class="line">    _offset = 0xffffffffffffffff, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x602060, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0x0, </span><br><span class="line">    _mode = 0xffffffff, </span><br><span class="line">    _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x6021c8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种是FSOP，它是file stream oriented  programing的缩写，一个进程内所有的_IO_FILE使用_chain相互连接形成一个链表，而链表头部是_IO_list_all，FSOP即是劫持_IO_list_all伪造链表和其中的_IO_FILE项，伪造数据劫持后并不会直接去执行还需要触发，调用_IO_flush_all_lockp可以触发FSOP，这个函数会刷新_IO_list_all链表中所有项的文件流，相当于对每个FILE调用fflush，也对应着会调用_IO_FILE_plus.vtable中的_IO_overflow。</p><p>IO_flush_all_lockp源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">_IO_flush_all_lockp (int do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  int result = 0;</span><br><span class="line">  FILE *fp;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line">#endif</span><br><span class="line">  for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      if (do_lock)</span><br><span class="line">        _IO_flockfile (fp);</span><br><span class="line">      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)/*一些检查，需要绕过*/</span><br><span class="line">           || (_IO_vtable_offset (fp) == 0</span><br><span class="line">               &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))/*也可以绕过这个*/</span><br><span class="line">           )</span><br><span class="line">          &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)/*遍历_IO_list_all ，选出_IO_FILE作为_IO_OVERFLOW的参数，执行函数*/</span><br><span class="line">        result = EOF;</span><br><span class="line">      if (do_lock)</span><br><span class="line">        _IO_funlockfile (fp);</span><br><span class="line">      run_fp = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (0);</span><br><span class="line">#endif</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要使用_IO_flush_all_lockp触发FSOP可以使用以下方法，第2、3种方法一般最常用：</p><p>1、当libc执行abort流程时abort会触发malloc_printerr触发FSOP<br>2、当执行exit函数时<br>3、当执行流从main函数返回时</p><p>FSOP攻击的前提条件：</p><p>1、知道libc地址获取_IO_lsit_all地址</p><p>2、可以任意地址写修改 _IO_list_all为可控地址</p><p>3、可以在可控内存中伪造_IO_FILE_plus结构</p><p>第3条中要想让伪造的fake_FILE需要满足一个条件：</p><p>1、fp-&gt;_mode &lt;= 0<br>2、fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</p><p>glibc2.24后增加了对劫持vtable的检测，glibc会在调用虚函数之前首先检查vtable地址的合法性。首先会验证vtable是否位于_IO_vtable段中，如果满足条件就正常执行，否则会调用_IO_vtable_check做进一步检查。</p><p>未完待续。。。。。。。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>关于IO_FILE这部分知识太多了，仅仅只是pwn部分关于IO_FILE的利用方式就不仅只有上面3种利用方式，还有任意地址读写、利用stream_buffer等利用方法，但还没看，最近只是简单看了下IO_FILE原理和利用方法，还没有去做题实践，以后有时间会再次补充下上面的内容。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://ctf-wiki.org/pwn/linux/io_file/introduction/">https://ctf-wiki.org/pwn/linux/io_file/introduction/</a></p><p><a href="https://ctf-wiki.org/pwn/linux/io_file/fake-vtable-exploit/">https://ctf-wiki.org/pwn/linux/io_file/fake-vtable-exploit/</a></p><p><a href="https://ctf-wiki.org/pwn/linux/io_file/fsop/">https://ctf-wiki.org/pwn/linux/io_file/fsop/</a></p><p><a href="https://blog.csdn.net/qq_41202237/article/details/113845320">https://blog.csdn.net/qq_41202237/article/details/113845320</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;IO-FILE笔记&quot;&gt;&lt;a href=&quot;#IO-FILE笔记&quot; class=&quot;headerlink&quot; title=&quot;IO_FILE笔记&quot;&gt;&lt;/a&gt;IO_FILE笔记&lt;/h1&gt;&lt;p&gt;一篇关于IO_FILE学习的笔记，因为作者这部分刚看所以记录的知识比较肤浅，大部分是作者自己的推测和理解，如果哪里错了请大佬看到轻喷。&lt;/p&gt;</summary>
    
    
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
  </entry>
  
</feed>
